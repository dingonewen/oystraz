This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/**, data/raw/**, *.csv, backend/app/config.py, WXWork/**, WeChat Files/**, dist/**, build/**, *-Copy*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/app/__init__.py
backend/app/database.py
backend/app/main.py
backend/app/models/__init__.py
backend/app/models/character.py
backend/app/models/diet.py
backend/app/models/exercise.py
backend/app/models/sleep.py
backend/app/models/user.py
backend/app/models/workplace.py
backend/app/routers/__init__.py
backend/app/routers/assistant.py
backend/app/routers/auth.py
backend/app/routers/character.py
backend/app/routers/diet.py
backend/app/routers/exercise.py
backend/app/routers/sleep.py
backend/app/routers/user.py
backend/app/schemas/__init__.py
backend/app/schemas/auth.py
backend/app/schemas/character.py
backend/app/schemas/diet.py
backend/app/schemas/exercise.py
backend/app/schemas/sleep.py
backend/app/schemas/user.py
backend/app/schemas/workplace.py
backend/app/services/__init__.py
backend/app/services/auth.py
backend/app/services/gemini.py
backend/app/services/usda.py
backend/check_gemini_models.py
backend/README
backend/requirements.txt
frontend/.env.example
frontend/.gitignore
frontend/eslint.config
frontend/index.html
frontend/package.json
frontend/src/App.css
frontend/src/App.tsx
frontend/src/components/PearlAssistant.tsx
frontend/src/components/Track/DietLog.tsx
frontend/src/components/Track/ExerciseLog.tsx
frontend/src/components/Track/SleepLog.tsx
frontend/src/config/api.ts
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/Home.tsx
frontend/src/pages/Login.tsx
frontend/src/pages/Profile.tsx
frontend/src/pages/Register.tsx
frontend/src/pages/Stats.tsx
frontend/src/pages/Track.tsx
frontend/src/pages/Work.tsx
frontend/src/services/aiService.ts
frontend/src/services/api.ts
frontend/src/services/authService.ts
frontend/src/services/characterService.ts
frontend/src/services/exerciseService.ts
frontend/src/services/foodService.ts
frontend/src/services/geminiService.ts
frontend/src/services/healthService.ts
frontend/src/services/pearlService.ts
frontend/src/store/characterStore.ts
frontend/src/store/userStore.ts
frontend/src/store/workStore.ts
frontend/src/types/index.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config
quick-start.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
.venv

# Node
node_modules/
npm-debug.log*
yarn-debug.log*

# Environment variables
.env
.env.local
.env.production

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Distribution / Build
dist/
build/
*.egg-info/

# Databases
*.db
*.sqlite
*.sqlite3

# Logs
*.log

# OS
Thumbs.db
</file>

<file path="backend/app/__init__.py">

</file>

<file path="backend/app/database.py">
"""
Database connection and session management
"""
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import settings

# Create database engine
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=settings.DEBUG
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()


def get_db():
    """
    Dependency function to get database session
    Use with FastAPI's Depends()
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="backend/app/main.py">
"""
FastAPI application entry point
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.config import settings
from app.database import Base, engine
from app.routers import auth, user, character, diet, exercise, sleep, assistant

# Create database tables
Base.metadata.create_all(bind=engine)

# Initialize FastAPI app
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    debug=settings.DEBUG
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth.router)
app.include_router(user.router)
app.include_router(character.router)
app.include_router(diet.router)
app.include_router(exercise.router)
app.include_router(sleep.router)
app.include_router(assistant.router)


@app.get("/")
def read_root():
    """Root endpoint"""
    return {
        "name": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "status": "running"
    }


@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=settings.DEBUG)
</file>

<file path="backend/app/models/__init__.py">
"""
Database models
"""
from app.models.user import User
from app.models.character import Character
from app.models.diet import DietLog
from app.models.exercise import ExerciseLog
from app.models.sleep import SleepLog
from app.models.workplace import WorkplaceEvent

__all__ = [
    "User",
    "Character",
    "DietLog",
    "ExerciseLog",
    "SleepLog",
    "WorkplaceEvent",
]
</file>

<file path="backend/app/models/character.py">
"""
Character database model
"""
from sqlalchemy import Column, Integer, Float, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class Character(Base):
    """Virtual character model representing user's health state"""
    __tablename__ = "characters"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True, nullable=False)

    # Health metrics (0-100)
    stamina = Column(Float, default=100.0)
    energy = Column(Float, default=100.0)
    nutrition = Column(Float, default=100.0)
    mood = Column(Float, default=100.0)
    stress = Column(Float, default=0.0)

    # Character progression
    level = Column(Integer, default=1)
    experience = Column(Integer, default=0)

    # Appearance states
    body_type = Column(String, default="normal")  # thin, normal, overweight, obese
    emotional_state = Column(String, default="normal")  # happy, normal, tired, stressed, angry

    # Timestamps
    last_updated = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="character")
</file>

<file path="backend/app/models/diet.py">
"""
Diet log database model
"""
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class DietLog(Base):
    """Food/meal tracking log"""
    __tablename__ = "diet_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # Food details
    food_name = Column(String, nullable=False)
    meal_type = Column(String)  # breakfast, lunch, dinner, snack

    # Nutrition info (from USDA API)
    calories = Column(Float, default=0.0)
    protein = Column(Float, default=0.0)  # grams
    carbs = Column(Float, default=0.0)  # grams
    fat = Column(Float, default=0.0)  # grams
    fiber = Column(Float, default=0.0)  # grams

    # Serving info
    serving_size = Column(Float, default=1.0)
    serving_unit = Column(String, default="serving")

    # Additional info
    notes = Column(Text)

    # Timestamps
    logged_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="diet_logs")
</file>

<file path="backend/app/models/exercise.py">
"""
Exercise log database model
"""
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class ExerciseLog(Base):
    """Exercise/activity tracking log"""
    __tablename__ = "exercise_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # Exercise details
    activity_name = Column(String, nullable=False)
    activity_type = Column(String)  # cardio, strength, flexibility, sports

    # Duration and intensity
    duration_minutes = Column(Float, nullable=False)
    intensity = Column(String, default="moderate")  # light, moderate, vigorous
    calories_burned = Column(Float, default=0.0)

    # Distance (for running, cycling, etc.)
    distance = Column(Float)  # in km
    distance_unit = Column(String, default="km")

    # Additional metrics
    heart_rate_avg = Column(Integer)
    steps = Column(Integer)

    # Notes
    notes = Column(Text)

    # Timestamps
    logged_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="exercise_logs")
</file>

<file path="backend/app/models/sleep.py">
"""
Sleep log database model
"""
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class SleepLog(Base):
    """Sleep tracking log"""
    __tablename__ = "sleep_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # Sleep duration
    sleep_start = Column(DateTime, nullable=False)
    sleep_end = Column(DateTime, nullable=False)
    duration_hours = Column(Float, nullable=False)

    # Sleep quality
    quality = Column(String, default="average")  # poor, average, good, excellent
    quality_score = Column(Float)  # 0-100

    # Sleep stages (if available from wearables)
    deep_sleep_minutes = Column(Float)
    light_sleep_minutes = Column(Float)
    rem_sleep_minutes = Column(Float)
    awake_minutes = Column(Float)

    # Additional info
    interruptions = Column(Integer, default=0)
    notes = Column(Text)

    # Timestamps
    logged_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="sleep_logs")
</file>

<file path="backend/app/models/workplace.py">
"""
Workplace event database model
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class WorkplaceEvent(Base):
    """Workplace simulator event log"""
    __tablename__ = "workplace_events"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # Event details
    event_type = Column(String, nullable=False)  # meeting, presentation, conflict, break, etc.
    event_name = Column(String, nullable=False)
    outcome = Column(String)  # success, failure, neutral

    # Character state at event time
    character_state = Column(JSON)  # Snapshot of stamina, energy, mood, etc.

    # Event result
    description = Column(Text)
    consequences = Column(Text)  # What happened as a result
    experience_gained = Column(Integer, default=0)

    # Timestamps
    occurred_at = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="workplace_events")
</file>

<file path="backend/app/routers/__init__.py">
"""
API routers
"""
from app.routers import auth, user, character, diet, exercise, sleep, assistant

__all__ = ["auth", "user", "character", "diet", "exercise", "sleep", "assistant"]
</file>

<file path="backend/app/routers/auth.py">
"""
Authentication API routes
"""
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import User, Character
from app.schemas import UserRegister, Token
from app.services.auth import (
    authenticate_user,
    create_access_token,
    get_password_hash,
)
from app.config import settings

router = APIRouter(prefix="/api/auth", tags=["Authentication"])


@router.post("/register", response_model=Token, status_code=status.HTTP_201_CREATED)
def register(user_data: UserRegister, db: Session = Depends(get_db)):
    """Register a new user"""
    # Check if user already exists
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    if db.query(User).filter(User.username == user_data.username).first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )

    # Create new user
    new_user = User(
        email=user_data.email,
        username=user_data.username,
        hashed_password=get_password_hash(user_data.password),
        full_name=user_data.full_name
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    # Create character for the user
    character = Character(user_id=new_user.id)
    db.add(character)
    db.commit()

    # Create access token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": new_user.username}, expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}


@router.post("/login", response_model=Token)
def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """Login with username and password"""
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}
</file>

<file path="backend/app/routers/character.py">
"""
Character API routes
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import User, Character
from app.schemas import CharacterResponse, CharacterUpdate
from app.services.auth import get_current_user

router = APIRouter(prefix="/api/character", tags=["Character"])


@router.get("/", response_model=CharacterResponse)
async def get_character(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user's character"""
    character = db.query(Character).filter(Character.user_id == current_user.id).first()
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Character not found"
        )
    return character


@router.put("/", response_model=CharacterResponse)
async def update_character(
    character_update: CharacterUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user's character stats"""
    character = db.query(Character).filter(Character.user_id == current_user.id).first()
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Character not found"
        )

    # Update only provided fields
    update_data = character_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(character, field, value)

    # Update body type and emotional state based on stats
    _update_character_appearance(character)

    db.commit()
    db.refresh(character)

    return character


def _update_character_appearance(character: Character):
    """Update character's body type and emotional state based on health metrics"""
    # Update emotional state based on mood and stress
    if character.mood >= 80 and character.stress < 30:
        character.emotional_state = "happy"
    elif character.mood < 40 or character.energy < 30:
        character.emotional_state = "tired"
    elif character.stress >= 70:
        character.emotional_state = "stressed"
    elif character.stress >= 85:
        character.emotional_state = "angry"
    else:
        character.emotional_state = "normal"

    # Body type would be calculated based on user's BMI in a real scenario
    # For now, we'll keep it simple
</file>

<file path="backend/app/routers/diet.py">
"""
Diet tracking API routes
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, timedelta

from app.database import get_db
from app.models import User, DietLog
from app.schemas import DietLogCreate, DietLogUpdate, DietLogResponse
from app.services.auth import get_current_user

router = APIRouter(prefix="/api/diet", tags=["Diet"])


@router.post("/", response_model=DietLogResponse, status_code=status.HTTP_201_CREATED)
async def create_diet_log(
    diet_log: DietLogCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new diet log entry"""
    new_log = DietLog(
        user_id=current_user.id,
        **diet_log.model_dump()
    )
    db.add(new_log)
    db.commit()
    db.refresh(new_log)
    return new_log


@router.get("/", response_model=list[DietLogResponse])
async def get_diet_logs(
    days: int = 7,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get diet logs for the past N days"""
    start_date = datetime.utcnow() - timedelta(days=days)
    logs = db.query(DietLog).filter(
        DietLog.user_id == current_user.id,
        DietLog.logged_at >= start_date
    ).order_by(DietLog.logged_at.desc()).all()
    return logs


@router.get("/{log_id}", response_model=DietLogResponse)
async def get_diet_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific diet log by ID"""
    log = db.query(DietLog).filter(
        DietLog.id == log_id,
        DietLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Diet log not found"
        )
    return log


@router.put("/{log_id}", response_model=DietLogResponse)
async def update_diet_log(
    log_id: int,
    diet_update: DietLogUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a diet log"""
    log = db.query(DietLog).filter(
        DietLog.id == log_id,
        DietLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Diet log not found"
        )

    update_data = diet_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(log, field, value)

    db.commit()
    db.refresh(log)
    return log


@router.delete("/{log_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_diet_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a diet log"""
    log = db.query(DietLog).filter(
        DietLog.id == log_id,
        DietLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Diet log not found"
        )

    db.delete(log)
    db.commit()
</file>

<file path="backend/app/routers/exercise.py">
"""
Exercise tracking API routes
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, timedelta

from app.database import get_db
from app.models import User, ExerciseLog
from app.schemas import ExerciseLogCreate, ExerciseLogUpdate, ExerciseLogResponse
from app.services.auth import get_current_user

router = APIRouter(prefix="/api/exercise", tags=["Exercise"])


@router.post("/", response_model=ExerciseLogResponse, status_code=status.HTTP_201_CREATED)
async def create_exercise_log(
    exercise_log: ExerciseLogCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new exercise log entry"""
    new_log = ExerciseLog(
        user_id=current_user.id,
        **exercise_log.model_dump()
    )
    db.add(new_log)
    db.commit()
    db.refresh(new_log)
    return new_log


@router.get("/", response_model=list[ExerciseLogResponse])
async def get_exercise_logs(
    days: int = 7,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get exercise logs for the past N days"""
    start_date = datetime.utcnow() - timedelta(days=days)
    logs = db.query(ExerciseLog).filter(
        ExerciseLog.user_id == current_user.id,
        ExerciseLog.logged_at >= start_date
    ).order_by(ExerciseLog.logged_at.desc()).all()
    return logs


@router.get("/{log_id}", response_model=ExerciseLogResponse)
async def get_exercise_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific exercise log by ID"""
    log = db.query(ExerciseLog).filter(
        ExerciseLog.id == log_id,
        ExerciseLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exercise log not found"
        )
    return log


@router.delete("/{log_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_exercise_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete an exercise log"""
    log = db.query(ExerciseLog).filter(
        ExerciseLog.id == log_id,
        ExerciseLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exercise log not found"
        )

    db.delete(log)
    db.commit()
</file>

<file path="backend/app/routers/sleep.py">
"""
Sleep tracking API routes
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, timedelta

from app.database import get_db
from app.models import User, SleepLog
from app.schemas import SleepLogCreate, SleepLogUpdate, SleepLogResponse
from app.services.auth import get_current_user

router = APIRouter(prefix="/api/sleep", tags=["Sleep"])


@router.post("/", response_model=SleepLogResponse, status_code=status.HTTP_201_CREATED)
async def create_sleep_log(
    sleep_log: SleepLogCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new sleep log entry"""
    new_log = SleepLog(
        user_id=current_user.id,
        **sleep_log.model_dump()
    )
    db.add(new_log)
    db.commit()
    db.refresh(new_log)
    return new_log


@router.get("/", response_model=list[SleepLogResponse])
async def get_sleep_logs(
    days: int = 7,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get sleep logs for the past N days"""
    start_date = datetime.utcnow() - timedelta(days=days)
    logs = db.query(SleepLog).filter(
        SleepLog.user_id == current_user.id,
        SleepLog.logged_at >= start_date
    ).order_by(SleepLog.logged_at.desc()).all()
    return logs


@router.get("/{log_id}", response_model=SleepLogResponse)
async def get_sleep_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get a specific sleep log by ID"""
    log = db.query(SleepLog).filter(
        SleepLog.id == log_id,
        SleepLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sleep log not found"
        )
    return log


@router.delete("/{log_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_sleep_log(
    log_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a sleep log"""
    log = db.query(SleepLog).filter(
        SleepLog.id == log_id,
        SleepLog.user_id == current_user.id
    ).first()
    if not log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sleep log not found"
        )

    db.delete(log)
    db.commit()
</file>

<file path="backend/app/routers/user.py">
"""
User API routes
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import User
from app.schemas import UserResponse, UserUpdate
from app.services.auth import get_current_user

router = APIRouter(prefix="/api/users", tags=["Users"])


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """Get current user information"""
    return current_user


@router.put("/me", response_model=UserResponse)
async def update_current_user(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user information"""
    # Update only provided fields
    update_data = user_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(current_user, field, value)

    db.commit()
    db.refresh(current_user)

    return current_user
</file>

<file path="backend/app/schemas/__init__.py">
"""
Pydantic schemas
"""
from app.schemas.auth import UserRegister, UserLogin, Token, TokenData
from app.schemas.user import UserBase, UserCreate, UserUpdate, UserResponse
from app.schemas.character import CharacterBase, CharacterCreate, CharacterUpdate, CharacterResponse
from app.schemas.diet import DietLogBase, DietLogCreate, DietLogUpdate, DietLogResponse
from app.schemas.exercise import ExerciseLogBase, ExerciseLogCreate, ExerciseLogUpdate, ExerciseLogResponse
from app.schemas.sleep import SleepLogBase, SleepLogCreate, SleepLogUpdate, SleepLogResponse
from app.schemas.workplace import WorkplaceEventBase, WorkplaceEventCreate, WorkplaceEventResponse

__all__ = [
    "UserRegister",
    "UserLogin",
    "Token",
    "TokenData",
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserResponse",
    "CharacterBase",
    "CharacterCreate",
    "CharacterUpdate",
    "CharacterResponse",
    "DietLogBase",
    "DietLogCreate",
    "DietLogUpdate",
    "DietLogResponse",
    "ExerciseLogBase",
    "ExerciseLogCreate",
    "ExerciseLogUpdate",
    "ExerciseLogResponse",
    "SleepLogBase",
    "SleepLogCreate",
    "SleepLogUpdate",
    "SleepLogResponse",
    "WorkplaceEventBase",
    "WorkplaceEventCreate",
    "WorkplaceEventResponse",
]
</file>

<file path="backend/app/schemas/auth.py">
"""
Authentication schemas
"""
from pydantic import BaseModel, EmailStr


class UserRegister(BaseModel):
    """User registration schema"""
    email: EmailStr
    username: str
    password: str
    full_name: str | None = None


class UserLogin(BaseModel):
    """User login schema"""
    username: str
    password: str


class Token(BaseModel):
    """JWT token response"""
    access_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    """Token payload data"""
    username: str | None = None
</file>

<file path="backend/app/schemas/character.py">
"""
Character schemas
"""
from pydantic import BaseModel, ConfigDict, Field
from datetime import datetime


class CharacterBase(BaseModel):
    """Base character schema"""
    stamina: float = Field(ge=0, le=100, default=100.0)
    energy: float = Field(ge=0, le=100, default=100.0)
    nutrition: float = Field(ge=0, le=100, default=100.0)
    mood: float = Field(ge=0, le=100, default=100.0)
    stress: float = Field(ge=0, le=100, default=0.0)


class CharacterCreate(CharacterBase):
    """Character creation schema"""
    pass


class CharacterUpdate(BaseModel):
    """Character update schema"""
    stamina: float | None = Field(ge=0, le=100, default=None)
    energy: float | None = Field(ge=0, le=100, default=None)
    nutrition: float | None = Field(ge=0, le=100, default=None)
    mood: float | None = Field(ge=0, le=100, default=None)
    stress: float | None = Field(ge=0, le=100, default=None)


class CharacterResponse(CharacterBase):
    """Character response schema"""
    id: int
    user_id: int
    level: int
    experience: int
    body_type: str
    emotional_state: str
    last_updated: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/schemas/diet.py">
"""
Diet log schemas
"""
from pydantic import BaseModel, ConfigDict
from datetime import datetime


class DietLogBase(BaseModel):
    """Base diet log schema"""
    food_name: str
    meal_type: str | None = None
    calories: float = 0.0
    protein: float = 0.0
    carbs: float = 0.0
    fat: float = 0.0
    fiber: float = 0.0
    serving_size: float = 1.0
    serving_unit: str = "serving"
    notes: str | None = None


class DietLogCreate(DietLogBase):
    """Diet log creation schema"""
    logged_at: datetime | None = None


class DietLogUpdate(BaseModel):
    """Diet log update schema"""
    food_name: str | None = None
    meal_type: str | None = None
    calories: float | None = None
    protein: float | None = None
    carbs: float | None = None
    fat: float | None = None
    fiber: float | None = None
    serving_size: float | None = None
    serving_unit: str | None = None
    notes: str | None = None


class DietLogResponse(DietLogBase):
    """Diet log response schema"""
    id: int
    user_id: int
    logged_at: datetime
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/schemas/exercise.py">
"""
Exercise log schemas
"""
from pydantic import BaseModel, ConfigDict
from datetime import datetime


class ExerciseLogBase(BaseModel):
    """Base exercise log schema"""
    activity_name: str
    activity_type: str | None = None
    duration_minutes: float
    intensity: str = "moderate"
    calories_burned: float = 0.0
    distance: float | None = None
    distance_unit: str = "km"
    heart_rate_avg: int | None = None
    steps: int | None = None
    notes: str | None = None


class ExerciseLogCreate(ExerciseLogBase):
    """Exercise log creation schema"""
    logged_at: datetime | None = None


class ExerciseLogUpdate(BaseModel):
    """Exercise log update schema"""
    activity_name: str | None = None
    activity_type: str | None = None
    duration_minutes: float | None = None
    intensity: str | None = None
    calories_burned: float | None = None
    distance: float | None = None
    distance_unit: str | None = None
    heart_rate_avg: int | None = None
    steps: int | None = None
    notes: str | None = None


class ExerciseLogResponse(ExerciseLogBase):
    """Exercise log response schema"""
    id: int
    user_id: int
    logged_at: datetime
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/schemas/sleep.py">
"""
Sleep log schemas
"""
from pydantic import BaseModel, ConfigDict
from datetime import datetime


class SleepLogBase(BaseModel):
    """Base sleep log schema"""
    sleep_start: datetime
    sleep_end: datetime
    duration_hours: float
    quality: str = "average"
    quality_score: float | None = None
    deep_sleep_minutes: float | None = None
    light_sleep_minutes: float | None = None
    rem_sleep_minutes: float | None = None
    awake_minutes: float | None = None
    interruptions: int = 0
    notes: str | None = None


class SleepLogCreate(SleepLogBase):
    """Sleep log creation schema"""
    logged_at: datetime | None = None


class SleepLogUpdate(BaseModel):
    """Sleep log update schema"""
    sleep_start: datetime | None = None
    sleep_end: datetime | None = None
    duration_hours: float | None = None
    quality: str | None = None
    quality_score: float | None = None
    deep_sleep_minutes: float | None = None
    light_sleep_minutes: float | None = None
    rem_sleep_minutes: float | None = None
    awake_minutes: float | None = None
    interruptions: int | None = None
    notes: str | None = None


class SleepLogResponse(SleepLogBase):
    """Sleep log response schema"""
    id: int
    user_id: int
    logged_at: datetime
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/schemas/workplace.py">
"""
Workplace event schemas
"""
from pydantic import BaseModel, ConfigDict
from datetime import datetime


class WorkplaceEventBase(BaseModel):
    """Base workplace event schema"""
    event_type: str
    event_name: str
    outcome: str | None = None
    character_state: dict | None = None
    description: str | None = None
    consequences: str | None = None
    experience_gained: int = 0


class WorkplaceEventCreate(WorkplaceEventBase):
    """Workplace event creation schema"""
    occurred_at: datetime | None = None


class WorkplaceEventResponse(WorkplaceEventBase):
    """Workplace event response schema"""
    id: int
    user_id: int
    occurred_at: datetime
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/services/__init__.py">

</file>

<file path="backend/app/services/auth.py">
"""
Authentication service utilities
"""
from datetime import datetime, timedelta
from typing import Optional
from passlib.context import CryptContext
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from app.config import settings
from app.database import get_db
from app.models import User
from app.schemas import TokenData

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme for token authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/auth/login")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    """Authenticate a user with username and password"""
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user


async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """Get the current authenticated user from JWT token"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.username == token_data.username).first()
    if user is None:
        raise credentials_exception

    return user
</file>

<file path="backend/check_gemini_models.py">
"""
Check available Gemini models for your API key
"""
import google.generativeai as genai
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

api_key = os.getenv('GEMINI_API_KEY')

if not api_key:
    print("Error: GEMINI_API_KEY not found in .env file")
    exit(1)

genai.configure(api_key=api_key)

print("Available Gemini models:\n")
for model in genai.list_models():
    if 'generateContent' in model.supported_generation_methods:
        print(f"- {model.name}")
</file>

<file path="backend/README">
# Oystraz Backend API

FastAPI backend for the Oystraz health tracking application with Google Gemini AI integration.

## Features

- üîê **JWT Authentication** - Secure user registration and login
- üë§ **User Management** - Profile management with health metrics
- üéÆ **Character System** - Virtual character reflecting health state
- üçΩÔ∏è **Diet Tracking** - Log meals with USDA nutrition data
- üèÉ **Exercise Tracking** - Record workouts and activities
- üò¥ **Sleep Tracking** - Monitor sleep quality and duration
- ü§ñ **Gemini AI Assistant** - Personalized health insights
- üè¢ **Workplace Simulator** - AI-generated scenarios based on health
- üìä **USDA API Integration** - 600k+ foods nutrition database

## Tech Stack

- **Framework**: FastAPI 0.104+
- **Database**: PostgreSQL with SQLAlchemy ORM
- **Authentication**: JWT tokens with bcrypt password hashing
- **AI**: Google Gemini API
- **External APIs**: USDA FoodData Central
- **Python**: 3.11+

## Project Structure

```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ models/          # SQLAlchemy database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ character.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diet.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exercise.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sleep.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workplace.py
‚îÇ   ‚îú‚îÄ‚îÄ routers/         # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py      # Register/Login
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py      # User profile
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ character.py # Character management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diet.py      # Diet logging
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exercise.py  # Exercise logging
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sleep.py     # Sleep logging
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ assistant.py # AI & USDA APIs
‚îÇ   ‚îú‚îÄ‚îÄ schemas/         # Pydantic schemas
‚îÇ   ‚îú‚îÄ‚îÄ services/        # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py      # JWT & password utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gemini.py    # Gemini AI integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usda.py      # USDA API integration
‚îÇ   ‚îú‚îÄ‚îÄ config.py        # Configuration settings
‚îÇ   ‚îú‚îÄ‚îÄ database.py      # Database connection
‚îÇ   ‚îî‚îÄ‚îÄ main.py          # FastAPI app entry point
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îî‚îÄ‚îÄ README.md
```

## Setup Instructions

### 1. Prerequisites

- Python 3.11 or higher
- PostgreSQL 14 or higher
- pip (Python package manager)

### 2. Install Dependencies

```bash
cd backend
pip install -r requirements.txt
```

### 3. Database Setup

**Create PostgreSQL database:**

```bash
# Linux/Mac
sudo -u postgres psql
CREATE DATABASE oystraz;
CREATE USER oystraz_user WITH PASSWORD 'your_password';
GRANT ALL PRIVILEGES ON DATABASE oystraz TO oystraz_user;
\q

# Windows (using psql)
psql -U postgres
CREATE DATABASE oystraz;
```

### 4. Environment Configuration

```bash
# Copy example environment file
cp .env.example .env

# Edit .env with your settings
nano .env  # or use any text editor
```

**Required environment variables:**

```env
DATABASE_URL=postgresql://oystraz_user:your_password@localhost:5432/oystraz
SECRET_KEY=<generate using: openssl rand -hex 32>
GEMINI_API_KEY=<your Google AI Studio API key>
USDA_API_KEY=<your USDA FoodData Central API key>
```

**Get API Keys:**

- **Gemini API**: https://makersuite.google.com/app/apikey
- **USDA API**: https://fdc.nal.usda.gov/api-key-signup.html (free)

### 5. Initialize Database

The database tables will be automatically created when you first run the application.

```bash
# Run the application (tables auto-create)
python -m app.main
```

Alternatively, you can create tables manually:

```python
from app.database import engine, Base
from app.models import *  # Import all models
Base.metadata.create_all(bind=engine)
```

### 6. Run the Server

**Development mode (with auto-reload):**

```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

**Production mode:**

```bash
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### 7. Access API Documentation

FastAPI provides automatic interactive API documentation:

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register new user
- `POST /api/auth/login` - Login and get JWT token

### User Management

- `GET /api/users/me` - Get current user info
- `PUT /api/users/me` - Update user profile

### Character

- `GET /api/character` - Get user's character
- `PUT /api/character` - Update character stats

### Health Tracking

- `POST /api/diet` - Create diet log
- `GET /api/diet` - Get diet logs (last N days)
- `PUT /api/diet/{log_id}` - Update diet log
- `DELETE /api/diet/{log_id}` - Delete diet log

*(Similar endpoints for `/api/exercise` and `/api/sleep`)*

### AI Assistant

- `POST /api/assistant/advice` - Get personalized health advice from Gemini
- `POST /api/assistant/workplace-scenario` - Generate workplace scenario
- `POST /api/assistant/food-search` - Search USDA food database
- `GET /api/assistant/food/{fdc_id}` - Get food nutrition details

## Usage Examples

### Register a new user

```bash
curl -X POST "http://localhost:8000/api/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "username": "testuser",
    "password": "securepass123",
    "full_name": "Test User"
  }'
```

### Login and get token

```bash
curl -X POST "http://localhost:8000/api/auth/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=testuser&password=securepass123"
```

### Get character (with authentication)

```bash
curl -X GET "http://localhost:8000/api/character" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### Log a meal

```bash
curl -X POST "http://localhost:8000/api/diet" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "food_name": "Chicken Breast",
    "meal_type": "lunch",
    "calories": 165,
    "protein": 31,
    "carbs": 0,
    "fat": 3.6,
    "serving_size": 100,
    "serving_unit": "g"
  }'
```

### Get AI health advice

```bash
curl -X POST "http://localhost:8000/api/assistant/advice" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "How can I improve my energy levels?",
    "days": 7
  }'
```

## Development

### Running Tests

```bash
pytest
```

### Code Style

This project follows PEP 8 style guidelines. Format code with:

```bash
black app/
```

### Database Migrations (Optional)

For production, consider using Alembic for database migrations:

```bash
pip install alembic
alembic init alembic
# Configure alembic.ini and env.py
alembic revision --autogenerate -m "Initial migration"
alembic upgrade head
```

## Deployment

### Docker (Recommended)

```dockerfile
# Dockerfile example
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Environment Variables for Production

```env
DEBUG=False
SECRET_KEY=<use strong random key>
DATABASE_URL=<production database URL>
CORS_ORIGINS=https://yourdomain.com
```

## Troubleshooting

### Database connection errors

- Check PostgreSQL is running: `sudo systemctl status postgresql`
- Verify database credentials in `.env`
- Ensure database exists: `psql -U postgres -l`

### Import errors

- Make sure you're in the `backend/` directory
- Activate virtual environment if using one
- Reinstall dependencies: `pip install -r requirements.txt`

### API key errors

- Verify API keys are correctly set in `.env`
- Check API key quotas (USDA: 3,600 requests/hour)

## License

This project is part of the Oystraz health tracking application.

## Support

For issues and questions, please open an issue on the project repository.
</file>

<file path="backend/requirements.txt">
# FastAPI and server
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.23
psycopg2-binary==2.9.9

# Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# Configuration
pydantic==2.5.0
pydantic-settings==2.1.0
python-dotenv==1.0.0

# HTTP client
httpx==0.25.1

# Google Gemini AI
google-generativeai==0.3.1

# Development
pytest==7.4.3
pytest-asyncio==0.21.1
</file>

<file path="frontend/.env.example">
# Oystraz Frontend Environment Variables
# Copy this file to .env and fill in your actual values

# Backend API URL
VITE_API_URL=http://localhost:8000/api

# For development, you can leave this as is
# For production, update to your deployed backend URL
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Dependencies
node_modules
dist
dist-ssr
*.local

# Environment variables
.env
.env.local
.env.production

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/eslint.config">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.7",
    "@mui/material": "^7.3.7",
    "axios": "^1.13.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.12.0",
    "recharts": "^3.6.0",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="frontend/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="frontend/src/components/PearlAssistant.tsx">
/**
 * Pearl AI Assistant - Global Floating Chat Widget
 * A laid-back, WLB-focused AI assistant that cares about your health
 */

import { useState, useRef, useEffect } from 'react';
import { chatWithPearl } from '../services/pearlService';
import {
  Box,
  Fab,
  Paper,
  Typography,
  TextField,
  IconButton,
  CircularProgress,
  Fade,
  Avatar,
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import MinimizeIcon from '@mui/icons-material/Minimize';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export default function PearlAssistant() {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([
    {
      role: 'assistant',
      content: "Hey there! I'm Pearl üíé Your chill health buddy. No pressure, no corporate BS - just here to help you take care of yourself. What's on your mind?",
      timestamp: new Date(),
    },
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when new messages arrive
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleSend = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input.trim(),
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    const userInput = input.trim();
    setInput('');
    setIsLoading(true);

    try {
      // Call Pearl API with conversation history
      const response = await chatWithPearl(userInput);

      const assistantMessage: Message = {
        role: 'assistant',
        content: response,
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      const errorMessage: Message = {
        role: 'assistant',
        content: "Oops, something went wrong. Even I need a break sometimes üòÖ",
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <>
      {/* Floating Button */}
      {!isOpen && (
        <Fab
          color="primary"
          aria-label="open pearl assistant"
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            width: 64,
            height: 64,
            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            '&:hover': {
              background: 'linear-gradient(135deg, #764ba2 0%, #667eea 100%)',
            },
          }}
          onClick={handleToggle}
        >
          <Typography sx={{ fontSize: '2rem' }}>üíé</Typography>
        </Fab>
      )}

      {/* Chat Window */}
      <Fade in={isOpen}>
        <Paper
          elevation={8}
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            width: 380,
            height: 600,
            display: isOpen ? 'flex' : 'none',
            flexDirection: 'column',
            borderRadius: 3,
            overflow: 'hidden',
            zIndex: 1300,
          }}
        >
          {/* Header */}
          <Box
            sx={{
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              color: 'white',
              p: 2,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
            }}
          >
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
              <Avatar sx={{ bgcolor: 'rgba(255,255,255,0.2)' }}>üíé</Avatar>
              <Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  Pearl
                </Typography>
                <Typography variant="caption" sx={{ opacity: 0.9 }}>
                  Your chill health buddy
                </Typography>
              </Box>
            </Box>
            <Box>
              <IconButton
                size="small"
                onClick={handleToggle}
                sx={{ color: 'white' }}
              >
                <MinimizeIcon />
              </IconButton>
            </Box>
          </Box>

          {/* Messages */}
          <Box
            sx={{
              flex: 1,
              overflowY: 'auto',
              p: 2,
              bgcolor: '#f5f5f5',
              display: 'flex',
              flexDirection: 'column',
              gap: 2,
            }}
          >
            {messages.map((message, index) => (
              <Box
                key={index}
                sx={{
                  display: 'flex',
                  justifyContent: message.role === 'user' ? 'flex-end' : 'flex-start',
                }}
              >
                <Paper
                  elevation={1}
                  sx={{
                    p: 1.5,
                    maxWidth: '80%',
                    bgcolor: message.role === 'user' ? '#667eea' : 'white',
                    color: message.role === 'user' ? 'white' : 'text.primary',
                    borderRadius: 2,
                  }}
                >
                  <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>
                    {message.content}
                  </Typography>
                  <Typography
                    variant="caption"
                    sx={{
                      opacity: 0.7,
                      display: 'block',
                      mt: 0.5,
                      fontSize: '0.65rem',
                    }}
                  >
                    {message.timestamp.toLocaleTimeString([], {
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </Typography>
                </Paper>
              </Box>
            ))}
            {isLoading && (
              <Box sx={{ display: 'flex', justifyContent: 'flex-start' }}>
                <Paper elevation={1} sx={{ p: 1.5, borderRadius: 2 }}>
                  <CircularProgress size={20} />
                </Paper>
              </Box>
            )}
            <div ref={messagesEndRef} />
          </Box>

          {/* Input */}
          <Box
            sx={{
              p: 2,
              bgcolor: 'white',
              borderTop: '1px solid',
              borderColor: 'divider',
            }}
          >
            <Box sx={{ display: 'flex', gap: 1 }}>
              <TextField
                fullWidth
                multiline
                maxRows={3}
                size="small"
                placeholder="Ask Pearl anything..."
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={handleKeyPress}
                disabled={isLoading}
                sx={{
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              <IconButton
                color="primary"
                onClick={handleSend}
                disabled={!input.trim() || isLoading}
                sx={{
                  bgcolor: '#667eea',
                  color: 'white',
                  '&:hover': {
                    bgcolor: '#764ba2',
                  },
                  '&.Mui-disabled': {
                    bgcolor: 'action.disabledBackground',
                  },
                }}
              >
                <SendIcon />
              </IconButton>
            </Box>
          </Box>
        </Paper>
      </Fade>
    </>
  );
}
</file>

<file path="frontend/src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="frontend/src/pages/Login.tsx">
/**
 * Login Page
 */
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  Link,
} from '@mui/material';
import { login, getCurrentUser } from '../services/authService';
import { useUserStore } from '../store/userStore';

export default function Login() {
  const navigate = useNavigate();
  const { setUser, setToken } = useUserStore();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      // Login and get token
      const authResponse = await login({ username, password });
      setToken(authResponse.access_token);

      // Get user info
      const userResponse = await getCurrentUser();
      setUser(userResponse);

      // Redirect to home
      navigate('/');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 8 }}>
        <Paper sx={{ p: 4 }}>
          <Typography variant="h4" align="center" gutterBottom>
            Welcome to Oystraz
          </Typography>
          <Typography variant="body2" align="center" color="text.secondary" sx={{ mb: 3 }}>
            The world is your oyster when your health orchestrates harmony
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              margin="normal"
              required
              autoFocus
            />
            <TextField
              fullWidth
              label="Password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              margin="normal"
              required
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              disabled={loading}
              sx={{ mt: 3, mb: 2 }}
            >
              {loading ? 'Logging in...' : 'Login'}
            </Button>
          </form>

          <Box sx={{ mt: 2, textAlign: 'center' }}>
            <Typography variant="body2">
              Don't have an account?{' '}
              <Link href="/register" sx={{ cursor: 'pointer' }}>
                Register here
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

<file path="frontend/src/services/api.ts">
/**
 * Base API Client
 * Centralized HTTP client with authentication and error handling
 */

import axios, { AxiosInstance, AxiosError } from 'axios';
import { useUserStore } from '../store/userStore';

// Create axios instance
const api: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - add auth token
api.interceptors.request.use(
  (config) => {
    const token = useUserStore.getState().token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - handle errors globally
api.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Unauthorized - logout user
      useUserStore.getState().logout();
      window.location.href = '/login';
    }

    // Extract error message
    const errorMessage =
      (error.response?.data as { message?: string })?.message ||
      error.message ||
      'An unexpected error occurred';

    return Promise.reject(new Error(errorMessage));
  }
);

export default api;
</file>

<file path="frontend/src/services/characterService.ts">
/**
 * Character API service
 */
import api from './api';
import { API_ENDPOINTS } from '../config/api';
import type { CharacterState } from '../types';

export interface CharacterResponse {
  id: number;
  user_id: number;
  stamina: number;
  energy: number;
  nutrition: number;
  mood: number;
  stress: number;
  level: number;
  experience: number;
  body_type: string;
  emotional_state: string;
  last_updated: string;
}

/**
 * Get user's character
 */
export const getCharacter = async (): Promise<CharacterResponse> => {
  const response = await api.get<CharacterResponse>(API_ENDPOINTS.character);
  return response.data;
};

/**
 * Update character stats
 */
export const updateCharacter = async (
  data: Partial<CharacterState>
): Promise<CharacterResponse> => {
  const response = await api.put<CharacterResponse>(API_ENDPOINTS.character, data);
  return response.data;
};
</file>

<file path="frontend/src/services/exerciseService.ts">
/**
 * Exercise Service
 * Handles exercise logging and calorie calculations
 */

import api from './api';
import { Exercise, ApiResponse } from '../types';

export const exerciseService = {
  /**
   * Log an exercise session
   */
  logExercise: async (exercise: Omit<Exercise, 'id'>): Promise<Exercise> => {
    const response = await api.post<ApiResponse<Exercise>>(
      '/exercises',
      exercise
    );
    if (!response.data.data) {
      throw new Error('Failed to log exercise');
    }
    return response.data.data;
  },

  /**
   * Get exercise history
   */
  getExerciseHistory: async (
    startDate?: string,
    endDate?: string
  ): Promise<Exercise[]> => {
    const response = await api.get<ApiResponse<Exercise[]>>('/exercises', {
      params: { startDate, endDate },
    });
    return response.data.data || [];
  },

  /**
   * Calculate calories burned for an activity
   */
  calculateCalories: async (
    exerciseType: string,
    duration: number,
    weight: number
  ): Promise<number> => {
    const response = await api.post<ApiResponse<{ calories: number }>>(
      '/exercises/calculate',
      {
        exerciseType,
        duration,
        weight,
      }
    );
    return response.data.data?.calories || 0;
  },

  /**
   * Get list of available exercise types
   */
  getExerciseTypes: async (): Promise<string[]> => {
    const response = await api.get<ApiResponse<string[]>>(
      '/exercises/types'
    );
    return response.data.data || [];
  },
};
</file>

<file path="frontend/src/services/foodService.ts">
/**
 * Food Service
 * Handles food search and meal logging
 */

import api from './api';
import { FoodItem, Meal, ApiResponse } from '../types';

export const foodService = {
  /**
   * Search for food items using USDA database or local RAG
   */
  searchFood: async (query: string): Promise<FoodItem[]> => {
    const response = await api.get<ApiResponse<FoodItem[]>>('/food/search', {
      params: { q: query },
    });
    return response.data.data || [];
  },

  /**
   * Get food details by ID
   */
  getFoodById: async (id: string): Promise<FoodItem> => {
    const response = await api.get<ApiResponse<FoodItem>>(`/food/${id}`);
    if (!response.data.data) {
      throw new Error('Food not found');
    }
    return response.data.data;
  },

  /**
   * Log a meal
   */
  logMeal: async (meal: Omit<Meal, 'id'>): Promise<Meal> => {
    const response = await api.post<ApiResponse<Meal>>('/meals', meal);
    if (!response.data.data) {
      throw new Error('Failed to log meal');
    }
    return response.data.data;
  },

  /**
   * Get user's meal history
   */
  getMealHistory: async (
    startDate?: string,
    endDate?: string
  ): Promise<Meal[]> => {
    const response = await api.get<ApiResponse<Meal[]>>('/meals', {
      params: { startDate, endDate },
    });
    return response.data.data || [];
  },

  /**
   * Analyze food from image using Gemini Vision
   */
  analyzeFoodImage: async (imageFile: File): Promise<FoodItem[]> => {
    const formData = new FormData();
    formData.append('image', imageFile);

    const response = await api.post<ApiResponse<FoodItem[]>>(
      '/food/analyze-image',
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );
    return response.data.data || [];
  },
};
</file>

<file path="frontend/src/services/geminiService.ts">
/**
 * Gemini AI Service
 * Handles AI chat and conversations
 */

import api from './api';
import { ChatMessage, CharacterState, ApiResponse } from '../types';

export const geminiService = {
  /**
   * Send a message to the AI coach
   */
  sendMessage: async (
    message: string,
    characterState: CharacterState,
    conversationHistory: ChatMessage[]
  ): Promise<ChatMessage> => {
    const response = await api.post<ApiResponse<ChatMessage>>('/ai/chat', {
      message,
      characterState,
      conversationHistory,
    });

    if (!response.data.data) {
      throw new Error('Failed to get AI response');
    }

    return response.data.data;
  },

  /**
   * Get health advice based on current character state
   */
  getHealthAdvice: async (
    characterState: CharacterState
  ): Promise<string> => {
    const response = await api.post<ApiResponse<{ advice: string }>>(
      '/ai/advice',
      { characterState }
    );

    return response.data.data?.advice || 'Stay healthy!';
  },

  /**
   * Get commentary on a workplace event
   */
  getEventCommentary: async (
    eventType: string,
    userChoice: string,
    consequences: Partial<CharacterState>
  ): Promise<string> => {
    const response = await api.post<ApiResponse<{ commentary: string }>>(
      '/ai/event-commentary',
      {
        eventType,
        userChoice,
        consequences,
      }
    );

    return (
      response.data.data?.commentary ||
      'Interesting choice!'
    );
  },
};
</file>

<file path="frontend/src/services/pearlService.ts">
/**
 * Pearl AI Assistant Service
 */

import api from './api';
import { API_ENDPOINTS } from '../config/api';

interface PearlChatRequest {
  message: string;
  conversation_history?: any[];
}

interface PearlChatResponse {
  response: string;
}

/**
 * Send a message to Pearl AI assistant
 */
export const chatWithPearl = async (
  message: string,
  conversationHistory?: any[]
): Promise<string> => {
  const response = await api.post<PearlChatResponse>(
    API_ENDPOINTS.pearlChat,
    {
      message,
      conversation_history: conversationHistory,
    } as PearlChatRequest
  );

  return response.data.response;
};
</file>

<file path="frontend/src/store/characterStore.ts">
/**
 * Character State Management
 * Manages the virtual character's health metrics and state
 */

import { create } from 'zustand';
import { CharacterState } from '../types';

interface CharacterStore {
  // State
  character: CharacterState | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  setCharacter: (character: CharacterState) => void;
  updateMetric: (metric: keyof CharacterState, value: number) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  resetCharacter: () => void;
}

const initialCharacterState: CharacterState = {
  stamina: 50,
  energy: 50,
  nutrition: 50,
  mood: 50,
  stress: 50,
  level: 1,
  experience: 0,
  bodyType: 'normal',
  emotionalState: 'normal',
};

export const useCharacterStore = create<CharacterStore>((set) => ({
  // Initial state
  character: initialCharacterState,
  isLoading: false,
  error: null,

  // Actions
  setCharacter: (character) => set({ character }),

  updateMetric: (metric, value) =>
    set((state) => ({
      character: state.character
        ? { ...state.character, [metric]: Math.max(0, Math.min(100, value)) }
        : null,
    })),

  setLoading: (isLoading) => set({ isLoading }),

  setError: (error) => set({ error }),

  resetCharacter: () => set({ character: initialCharacterState, error: null }),
}));
</file>

<file path="frontend/src/store/userStore.ts">
/**
 * User State Management
 * Manages user authentication and profile data
 */

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User } from '../types';

interface UserStore {
  // State
  user: User | null;
  isAuthenticated: boolean;
  token: string | null;

  // Actions
  setUser: (user: User) => void;
  setToken: (token: string) => void;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => void;
}

export const useUserStore = create<UserStore>()(
  persist(
    (set) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      token: null,

      // Actions
      setUser: (user) => set({ user, isAuthenticated: true }),

      setToken: (token) => set({ token }),

      logout: () => set({ user: null, isAuthenticated: false, token: null }),

      updateProfile: (updates) =>
        set((state) => ({
          user: state.user ? { ...state.user, ...updates } : null,
        })),
    }),
    {
      name: 'oystraz-user-storage', // localStorage key
    }
  )
);
</file>

<file path="frontend/src/store/workStore.ts">
/**
 * Work Simulation State Management
 * Manages workplace scenarios and events
 */

import { create } from 'zustand';
import { WorkEvent, WorkEventResult } from '../types';

interface WorkStore {
  // State
  currentEvent: WorkEvent | null;
  eventHistory: WorkEventResult[];
  isWorking: boolean;
  isLoading: boolean;

  // Actions
  setCurrentEvent: (event: WorkEvent | null) => void;
  addEventResult: (result: WorkEventResult) => void;
  startWork: () => void;
  endWork: () => void;
  setLoading: (isLoading: boolean) => void;
  clearHistory: () => void;
}

export const useWorkStore = create<WorkStore>((set) => ({
  // Initial state
  currentEvent: null,
  eventHistory: [],
  isWorking: false,
  isLoading: false,

  // Actions
  setCurrentEvent: (event) => set({ currentEvent: event }),

  addEventResult: (result) =>
    set((state) => ({
      eventHistory: [...state.eventHistory, result],
      currentEvent: null,
    })),

  startWork: () => set({ isWorking: true }),

  endWork: () => set({ isWorking: false, currentEvent: null }),

  setLoading: (isLoading) => set({ isLoading }),

  clearHistory: () => set({ eventHistory: [] }),
}));
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vite.config">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="quick-start.md">
# Oystraz Frontend

React + TypeScript + Vite frontend for the Oystraz health tracking application.

## üöÄ Quick Start

### Prerequisites
- Node.js 18+ and npm

### Installation

```bash
# Install dependencies
npm install

# Copy environment variables
cp .env.example .env

# Start development server
npm run dev
```

The app will be available at `http://localhost:5173`

## üì¶ Tech Stack

- **React 18** - UI framework
- **TypeScript** - Type safety
- **Vite** - Build tool
- **Material-UI (MUI)** - Component library
- **Zustand** - State management
- **React Router** - Routing
- **Axios** - HTTP client
- **Recharts** - Data visualization

## üèóÔ∏è Project Structure

```
src/
‚îú‚îÄ‚îÄ components/     # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ Avatar/
‚îÇ   ‚îú‚îÄ‚îÄ HealthBars/
‚îÇ   ‚îú‚îÄ‚îÄ FoodInput/
‚îÇ   ‚îú‚îÄ‚îÄ ExerciseLog/
‚îÇ   ‚îú‚îÄ‚îÄ WorkSimulator/
‚îÇ   ‚îú‚îÄ‚îÄ AIChat/
‚îÇ   ‚îî‚îÄ‚îÄ Dashboard/
‚îú‚îÄ‚îÄ pages/          # Page components
‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Track.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Work.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Stats.tsx
‚îÇ   ‚îî‚îÄ‚îÄ Profile.tsx
‚îú‚îÄ‚îÄ services/       # API services
‚îÇ   ‚îú‚îÄ‚îÄ api.ts
‚îÇ   ‚îú‚îÄ‚îÄ foodService.ts
‚îÇ   ‚îú‚îÄ‚îÄ exerciseService.ts
‚îÇ   ‚îî‚îÄ‚îÄ geminiService.ts
‚îú‚îÄ‚îÄ store/          # Zustand stores
‚îÇ   ‚îú‚îÄ‚îÄ userStore.ts
‚îÇ   ‚îú‚îÄ‚îÄ characterStore.ts
‚îÇ   ‚îî‚îÄ‚îÄ workStore.ts
‚îú‚îÄ‚îÄ types/          # TypeScript type definitions
‚îú‚îÄ‚îÄ utils/          # Utility functions
‚îî‚îÄ‚îÄ hooks/          # Custom React hooks
```

## üé® Color Scheme

- Primary (Health Green): `#4CAF50`
- Secondary (Energy Blue): `#2196F3`
- Error (Stress Red): `#F44336`
- Warning (Caution Orange): `#FF9800`
- Background: `#FAFAFA`

## üìù Available Scripts

```bash
# Development
npm run dev          # Start dev server with hot reload

# Build
npm run build        # Build for production
npm run preview      # Preview production build locally

# Linting
npm run lint         # Run ESLint
```

## üîó API Configuration

Update `.env` file with your backend API URL:

```env
VITE_API_URL=http://localhost:8000/api
```

## üß™ Development Notes

- The app uses MUI's theming system for consistent styling
- State management is handled by Zustand (lightweight alternative to Redux)
- API calls are centralized in the `services/` directory
- All types are defined in `types/index.ts`

## üöß TODO

- [ ] Implement individual components (Avatar, HealthBars, etc.)
- [ ] Add form validation
- [ ] Implement authentication flow
- [ ] Add loading states and error boundaries
- [ ] Add unit tests
- [ ] Configure PWA features

## üìÑ License

MIT
</file>

<file path="backend/app/models/user.py">
"""
User database model
"""
from sqlalchemy import Column, Integer, String, DateTime, Float
from sqlalchemy.orm import relationship
from datetime import datetime
from app.database import Base


class User(Base):
    """User account model"""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)

    # Personal info
    full_name = Column(String)
    age = Column(Integer)
    gender = Column(String)
    height = Column(Float)  # in cm
    weight = Column(Float)  # in kg
    goal = Column(String)  # Health goal: lose_weight, maintain, gain_muscle, improve_health

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    character = relationship("Character", back_populates="user", uselist=False)
    diet_logs = relationship("DietLog", back_populates="user", cascade="all, delete-orphan")
    exercise_logs = relationship("ExerciseLog", back_populates="user", cascade="all, delete-orphan")
    sleep_logs = relationship("SleepLog", back_populates="user", cascade="all, delete-orphan")
    workplace_events = relationship("WorkplaceEvent", back_populates="user", cascade="all, delete-orphan")
</file>

<file path="backend/app/routers/assistant.py">
"""
AI Assistant API routes (Gemini + USDA)
"""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import datetime, timedelta

from app.database import get_db
from app.models import User, Character, DietLog, ExerciseLog, SleepLog
from app.services.auth import get_current_user
from app.services.gemini import gemini_service
from app.services.usda import usda_service

router = APIRouter(prefix="/api/assistant", tags=["AI Assistant"])


class HealthAdviceRequest(BaseModel):
    """Request schema for health advice"""
    query: str | None = None
    days: int = 7


class FoodSearchRequest(BaseModel):
    """Request schema for food search"""
    query: str
    page_size: int = 10


class PearlChatRequest(BaseModel):
    """Request schema for Pearl chat"""
    message: str
    conversation_history: list | None = None


@router.post("/pearl/chat")
async def chat_with_pearl(
    request: PearlChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Chat with Pearl AI assistant"""
    # Get character state for context
    character = db.query(Character).filter(Character.user_id == current_user.id).first()
    character_state = None
    if character:
        character_state = {
            "stamina": character.stamina,
            "energy": character.energy,
            "nutrition": character.nutrition,
            "mood": character.mood,
            "stress": character.stress
        }

    # Get recent logs (last 7 days)
    start_date = datetime.utcnow() - timedelta(days=7)
    recent_logs = None

    if character:
        diet_logs = db.query(DietLog).filter(
            DietLog.user_id == current_user.id,
            DietLog.logged_at >= start_date
        ).all()

        exercise_logs = db.query(ExerciseLog).filter(
            ExerciseLog.user_id == current_user.id,
            ExerciseLog.logged_at >= start_date
        ).all()

        sleep_logs = db.query(SleepLog).filter(
            SleepLog.user_id == current_user.id,
            SleepLog.logged_at >= start_date
        ).all()

        recent_logs = {
            "diet": [{"calories": log.calories} for log in diet_logs],
            "exercise": [{"duration_minutes": log.duration_minutes} for log in exercise_logs],
            "sleep": [{"duration_hours": log.duration_hours} for log in sleep_logs]
        }

    # Chat with Pearl
    response = gemini_service.pearl_chat(
        user_message=request.message,
        character_state=character_state,
        recent_logs=recent_logs,
        conversation_history=request.conversation_history
    )

    return {"response": response}


@router.post("/advice")
async def get_health_advice(
    request: HealthAdviceRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get personalized health advice from Gemini AI"""
    # Get character state
    character = db.query(Character).filter(Character.user_id == current_user.id).first()
    if not character:
        raise HTTPException(status_code=404, detail="Character not found")

    character_state = {
        "stamina": character.stamina,
        "energy": character.energy,
        "nutrition": character.nutrition,
        "mood": character.mood,
        "stress": character.stress
    }

    # Get recent logs
    start_date = datetime.utcnow() - timedelta(days=request.days)

    diet_logs = db.query(DietLog).filter(
        DietLog.user_id == current_user.id,
        DietLog.logged_at >= start_date
    ).all()

    exercise_logs = db.query(ExerciseLog).filter(
        ExerciseLog.user_id == current_user.id,
        ExerciseLog.logged_at >= start_date
    ).all()

    sleep_logs = db.query(SleepLog).filter(
        SleepLog.user_id == current_user.id,
        SleepLog.logged_at >= start_date
    ).all()

    recent_logs = {
        "diet": [{"calories": log.calories} for log in diet_logs],
        "exercise": [{"duration_minutes": log.duration_minutes} for log in exercise_logs],
        "sleep": [{"duration_hours": log.duration_hours} for log in sleep_logs]
    }

    # Generate advice
    advice = gemini_service.generate_health_advice(
        character_state=character_state,
        recent_logs=recent_logs,
        user_query=request.query
    )

    return {"advice": advice}


@router.post("/workplace-scenario")
async def generate_workplace_scenario(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Generate a workplace scenario based on current health state"""
    character = db.query(Character).filter(Character.user_id == current_user.id).first()
    if not character:
        raise HTTPException(status_code=404, detail="Character not found")

    character_state = {
        "stamina": character.stamina,
        "energy": character.energy,
        "mood": character.mood,
        "stress": character.stress
    }

    scenario = gemini_service.generate_workplace_scenario(character_state)
    return scenario


@router.post("/food-search")
async def search_foods(
    request: FoodSearchRequest,
    current_user: User = Depends(get_current_user)
):
    """Search for foods in USDA database"""
    results = await usda_service.search_foods(request.query, request.page_size)
    return {"foods": results}


@router.get("/food/{fdc_id}")
async def get_food_details(
    fdc_id: int,
    current_user: User = Depends(get_current_user)
):
    """Get detailed nutrition information for a food"""
    food_data = await usda_service.get_food_details(fdc_id)
    if not food_data:
        raise HTTPException(status_code=404, detail="Food not found")

    nutrition = usda_service.parse_nutrition(food_data)
    return {
        "food": food_data.get("description", "Unknown"),
        "nutrition": nutrition
    }
</file>

<file path="backend/app/schemas/user.py">
"""
User schemas
"""
from pydantic import BaseModel, EmailStr, ConfigDict
from datetime import datetime


class UserBase(BaseModel):
    """Base user schema"""
    email: EmailStr
    username: str
    full_name: str | None = None
    age: int | None = None
    gender: str | None = None
    height: float | None = None
    weight: float | None = None
    goal: str | None = None


class UserCreate(UserBase):
    """User creation schema"""
    password: str


class UserUpdate(BaseModel):
    """User update schema"""
    full_name: str | None = None
    age: int | None = None
    gender: str | None = None
    height: float | None = None
    weight: float | None = None
    goal: str | None = None


class UserResponse(UserBase):
    """User response schema"""
    id: int
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)
</file>

<file path="backend/app/services/usda.py">
"""
USDA FoodData Central API service
"""
import httpx
from typing import Optional, List
from app.config import settings


class USDAService:
    """Service for interacting with USDA FoodData Central API"""

    BASE_URL = "https://api.nal.usda.gov/fdc/v1"

    def __init__(self):
        self.api_key = settings.USDA_API_KEY

    async def search_foods(self, query: str, page_size: int = 10) -> List[dict]:
        """
        Search for foods in USDA database

        Args:
            query: Food name to search for
            page_size: Number of results to return

        Returns:
            List of food items with basic info
        """
        if not self.api_key:
            return [{
                "description": "USDA API not configured",
                "fdcId": 0,
                "dataType": "error"
            }]

        url = f"{self.BASE_URL}/foods/search"
        params = {
            "api_key": self.api_key,
            "query": query,
            "pageSize": page_size,
            # Include more data types for better coverage
            # Removed dataType filter to get all available foods
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url, params=params, timeout=10.0)
                response.raise_for_status()
                data = response.json()

                # Process foods to include calorie information
                foods = data.get("foods", [])
                processed_foods = []
                seen_descriptions = set()  # For simple deduplication

                for food in foods:
                    calories = self._extract_calories(food)

                    # Format description with proper capitalization
                    description = food.get("description", "Unknown Food")
                    description = self._format_description(description)

                    # Build contextual information
                    data_type = food.get("dataType", "")
                    brand = food.get("brandOwner", "")
                    if brand:
                        brand = self._clean_brand_name(brand)

                    # Create detailed description
                    # Only add brand name for branded foods, no labels for USDA data
                    detailed_desc = description
                    if brand:
                        detailed_desc = f"{description} ({brand})"

                    # Simple deduplication: skip very similar descriptions
                    # Create a normalized key for comparison
                    normalized_key = detailed_desc.lower().replace(" ", "")
                    if normalized_key in seen_descriptions:
                        continue
                    seen_descriptions.add(normalized_key)

                    food_item = {
                        "fdcId": food.get("fdcId"),
                        "description": detailed_desc,
                        "dataType": data_type,
                        "brandOwner": brand,
                        "calories": calories
                    }
                    processed_foods.append(food_item)

                return processed_foods
        except Exception as e:
            return [{
                "description": f"Error: {str(e)}",
                "fdcId": 0,
                "dataType": "error"
            }]

    async def get_food_details(self, fdc_id: int) -> Optional[dict]:
        """
        Get detailed nutrition information for a specific food

        Args:
            fdc_id: FoodData Central ID

        Returns:
            Detailed food information including all nutrients
        """
        if not self.api_key:
            return None

        url = f"{self.BASE_URL}/food/{fdc_id}"
        params = {"api_key": self.api_key}

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url, params=params, timeout=10.0)
                response.raise_for_status()
                return response.json()
        except Exception as e:
            return {"error": str(e)}

    def _clean_brand_name(self, brand: str) -> str:
        """
        Clean brand name by removing corporate suffixes

        Args:
            brand: Raw brand name

        Returns:
            Cleaned brand name
        """
        if not brand:
            return ""

        # Remove common corporate suffixes
        suffixes_to_remove = [
            ', Inc.', ' Inc.', ', Inc', ' Inc',
            ', LLC', ' LLC',
            ', Ltd.', ' Ltd.', ', Ltd', ' Ltd',
            ', Co.', ' Co.',
            ', Corp.', ' Corp.',
            ', Corporation', ' Corporation',
            ', L.L.C.', ' L.L.C.',
        ]

        cleaned = brand
        for suffix in suffixes_to_remove:
            if cleaned.endswith(suffix):
                cleaned = cleaned[:-len(suffix)]

        return cleaned.strip()

    def _format_description(self, description: str) -> str:
        """
        Format food description with proper capitalization

        Args:
            description: Raw food description

        Returns:
            Formatted description with title case
        """
        if not description:
            return "Unknown Food"

        # Convert to title case, but handle special cases
        # First, convert to lowercase
        desc = description.lower()

        # Split into words and capitalize appropriately
        words = desc.split()
        formatted_words = []

        # Words that should stay lowercase (unless at start)
        lowercase_words = {'with', 'and', 'or', 'the', 'in', 'on', 'at', 'to', 'for', 'of', 'by'}

        for i, word in enumerate(words):
            # First word or not in lowercase set: capitalize
            if i == 0 or word not in lowercase_words:
                formatted_words.append(word.capitalize())
            else:
                formatted_words.append(word)

        return ' '.join(formatted_words)

    def _extract_calories(self, food_item: dict) -> Optional[float]:
        """
        Extract calories from a food search result

        Args:
            food_item: Food item from search results

        Returns:
            Calories per 100g or None
        """
        nutrients = food_item.get("foodNutrients", [])
        for nutrient in nutrients:
            # Look for Energy/Calories
            name = nutrient.get("nutrientName", "").lower()
            if "energy" in name or "calorie" in name:
                # Prefer kcal over kJ
                unit = nutrient.get("unitName", "").lower()
                if "kcal" in unit or "calorie" in unit:
                    return nutrient.get("value", 0.0)

        return None

    def parse_nutrition(self, food_data: dict) -> dict:
        """
        Parse USDA food data into simplified nutrition info

        Args:
            food_data: Raw USDA food data

        Returns:
            Dict with calories, protein, carbs, fat, fiber
        """
        nutrients = food_data.get("foodNutrients", [])
        nutrition = {
            "calories": 0.0,
            "protein": 0.0,
            "carbs": 0.0,
            "fat": 0.0,
            "fiber": 0.0
        }

        # Map USDA nutrient IDs to our fields
        nutrient_map = {
            "Energy": "calories",
            "Protein": "protein",
            "Carbohydrate, by difference": "carbs",
            "Total lipid (fat)": "fat",
            "Fiber, total dietary": "fiber"
        }

        for nutrient in nutrients:
            name = nutrient.get("nutrientName", "")
            for usda_name, our_name in nutrient_map.items():
                if usda_name in name:
                    nutrition[our_name] = nutrient.get("value", 0.0)
                    break

        return nutrition


# Singleton instance
usda_service = USDAService()
</file>

<file path="frontend/src/pages/Register.tsx">
/**
 * Registration Page
 */
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  Link,
} from '@mui/material';
import { register, getCurrentUser } from '../services/authService';
import { useUserStore } from '../store/userStore';

export default function Register() {
  const navigate = useNavigate();
  const { setUser, setToken } = useUserStore();

  const [formData, setFormData] = useState({
    email: '',
    username: '',
    password: '',
    full_name: '',
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      // Register and get token
      const authResponse = await register(formData);
      setToken(authResponse.access_token);

      // Get user info
      const userResponse = await getCurrentUser();
      setUser(userResponse);

      // Redirect to home
      navigate('/');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 8 }}>
        <Paper sx={{ p: 4 }}>
          <Typography variant="h4" align="center" gutterBottom>
            Join Oystraz
          </Typography>
          <Typography variant="body2" align="center" color="text.secondary" sx={{ mb: 3 }}>
            Start your health journey today
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Email"
              name="email"
              type="email"
              value={formData.email}
              onChange={handleChange}
              margin="normal"
              required
              autoFocus
            />
            <TextField
              fullWidth
              label="Username"
              name="username"
              value={formData.username}
              onChange={handleChange}
              margin="normal"
              required
            />
            <TextField
              fullWidth
              label="Full Name"
              name="full_name"
              value={formData.full_name}
              onChange={handleChange}
              margin="normal"
            />
            <TextField
              fullWidth
              label="Password"
              name="password"
              type="password"
              value={formData.password}
              onChange={handleChange}
              margin="normal"
              required
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              disabled={loading}
              sx={{ mt: 3, mb: 2 }}
            >
              {loading ? 'Creating account...' : 'Register'}
            </Button>
          </form>

          <Box sx={{ mt: 2, textAlign: 'center' }}>
            <Typography variant="body2">
              Already have an account?{' '}
              <Link href="/login" sx={{ cursor: 'pointer' }}>
                Login here
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

<file path="frontend/src/services/aiService.ts">
/**
 * AI Assistant API service
 */
import api from './api';
import { API_ENDPOINTS } from '../config/api';

export interface HealthAdviceRequest {
  query?: string;
  days?: number;
}

export interface HealthAdviceResponse {
  advice: string;
}

export interface WorkplaceScenarioResponse {
  event_type: string;
  description: string;
  outcome: string;
}

export interface FoodSearchRequest {
  query: string;
  page_size?: number;
}

export interface FoodSearchResponse {
  foods: Array<{
    fdcId: number;
    description: string;
    dataType: string;
  }>;
}

export interface FoodDetailsResponse {
  food: string;
  nutrition: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
    fiber: number;
  };
}

/**
 * Get personalized health advice from Gemini AI
 */
export const getHealthAdvice = async (
  request: HealthAdviceRequest = {}
): Promise<HealthAdviceResponse> => {
  const response = await api.post<HealthAdviceResponse>(
    API_ENDPOINTS.aiAdvice,
    request
  );
  return response.data;
};

/**
 * Generate a workplace scenario based on current health state
 */
export const generateWorkplaceScenario = async (): Promise<WorkplaceScenarioResponse> => {
  const response = await api.post<WorkplaceScenarioResponse>(
    API_ENDPOINTS.workplaceScenario
  );
  return response.data;
};

/**
 * Search for foods in USDA database
 */
export const searchFoods = async (
  request: FoodSearchRequest
): Promise<FoodSearchResponse> => {
  const response = await api.post<FoodSearchResponse>(
    API_ENDPOINTS.foodSearch,
    request
  );
  return response.data;
};

/**
 * Get detailed nutrition information for a food
 */
export const getFoodDetails = async (fdcId: number): Promise<FoodDetailsResponse> => {
  const response = await api.get<FoodDetailsResponse>(
    API_ENDPOINTS.foodDetails(fdcId)
  );
  return response.data;
};

/**
 * Alias for generateWorkplaceScenario for Work page
 */
export const generateWorkScenario = generateWorkplaceScenario;
</file>

<file path="frontend/src/services/authService.ts">
/**
 * Authentication API service
 */
import api from './api';
import { API_ENDPOINTS } from '../config/api';

export interface RegisterData {
  email: string;
  username: string;
  password: string;
  full_name?: string;
}

export interface LoginData {
  username: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
}

export interface User {
  id: number;
  email: string;
  username: string;
  full_name?: string;
  age?: number;
  gender?: string;
  height?: number;
  weight?: number;
  goal?: string;
  created_at: string;
  updated_at: string;
}

/**
 * Register a new user
 */
export const register = async (data: RegisterData): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>(API_ENDPOINTS.register, data);
  return response.data;
};

/**
 * Login with username and password
 */
export const login = async (data: LoginData): Promise<AuthResponse> => {
  // FastAPI OAuth2 expects form data, not JSON
  const formData = new URLSearchParams();
  formData.append('username', data.username);
  formData.append('password', data.password);

  const response = await api.post<AuthResponse>(API_ENDPOINTS.login, formData, {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });
  return response.data;
};

/**
 * Get current user information
 */
export const getCurrentUser = async (): Promise<User> => {
  const response = await api.get<User>(API_ENDPOINTS.userMe);
  return response.data;
};

/**
 * Update user profile
 */
export const updateUser = async (data: Partial<User>): Promise<User> => {
  const response = await api.put<User>(API_ENDPOINTS.userMe, data);
  return response.data;
};
</file>

<file path="frontend/src/services/healthService.ts">
/**
 * Health tracking API service (diet, exercise, sleep)
 */
import api from './api';
import { API_ENDPOINTS } from '../config/api';
import type { DietLog, ExerciseLog, SleepLog } from '../types';

// Diet API

export interface DietLogCreate {
  food_name: string;
  meal_type?: string;
  calories?: number;
  protein?: number;
  carbs?: number;
  fat?: number;
  fiber?: number;
  serving_size?: number;
  serving_unit?: string;
  notes?: string;
  logged_at?: string;
}

export const createDietLog = async (data: DietLogCreate): Promise<DietLog> => {
  const response = await api.post<DietLog>(API_ENDPOINTS.diet, data);
  return response.data;
};

export const getDietLogs = async (days: number = 7): Promise<DietLog[]> => {
  const response = await api.get<DietLog[]>(`${API_ENDPOINTS.diet}?days=${days}`);
  return response.data;
};

export const deleteDietLog = async (logId: number): Promise<void> => {
  await api.delete(`${API_ENDPOINTS.diet}/${logId}`);
};

// Exercise API

export interface ExerciseLogCreate {
  activity_name: string;
  activity_type?: string;
  duration_minutes: number;
  intensity?: string;
  calories_burned?: number;
  distance?: number;
  distance_unit?: string;
  heart_rate_avg?: number;
  steps?: number;
  notes?: string;
  logged_at?: string;
}

export const createExerciseLog = async (data: ExerciseLogCreate): Promise<ExerciseLog> => {
  const response = await api.post<ExerciseLog>(API_ENDPOINTS.exercise, data);
  return response.data;
};

export const getExerciseLogs = async (days: number = 7): Promise<ExerciseLog[]> => {
  const response = await api.get<ExerciseLog[]>(`${API_ENDPOINTS.exercise}?days=${days}`);
  return response.data;
};

export const deleteExerciseLog = async (logId: number): Promise<void> => {
  await api.delete(`${API_ENDPOINTS.exercise}/${logId}`);
};

// Sleep API

export interface SleepLogCreate {
  sleep_start: string;
  sleep_end: string;
  duration_hours: number;
  quality?: string;
  quality_score?: number;
  deep_sleep_minutes?: number;
  light_sleep_minutes?: number;
  rem_sleep_minutes?: number;
  awake_minutes?: number;
  interruptions?: number;
  notes?: string;
  logged_at?: string;
}

export const createSleepLog = async (data: SleepLogCreate): Promise<SleepLog> => {
  const response = await api.post<SleepLog>(API_ENDPOINTS.sleep, data);
  return response.data;
};

export const getSleepLogs = async (days: number = 7): Promise<SleepLog[]> => {
  const response = await api.get<SleepLog[]>(`${API_ENDPOINTS.sleep}?days=${days}`);
  return response.data;
};

export const deleteSleepLog = async (logId: number): Promise<void> => {
  await api.delete(`${API_ENDPOINTS.sleep}/${logId}`);
};

// Convenience functions for components

export const logDiet = createDietLog;
export const logExercise = createExerciseLog;
export const logSleep = createSleepLog;

export const getTodayDietLogs = async (): Promise<DietLog[]> => {
  return getDietLogs(1);
};

export const getTodayExerciseLogs = async (): Promise<ExerciseLog[]> => {
  return getExerciseLogs(1);
};

export const getRecentSleepLogs = async (days: number = 7): Promise<SleepLog[]> => {
  return getSleepLogs(days);
};

// Food search
export interface FoodSearchResult {
  fdcId: number;
  description: string;
  calories?: number;
}

export const searchFoods = async (query: string): Promise<FoodSearchResult[]> => {
  const response = await api.post<{ foods: FoodSearchResult[] }>(
    API_ENDPOINTS.foodSearch,
    { query, page_size: 10 }
  );
  return response.data.foods;
};
</file>

<file path="frontend/src/types/index.ts">
/**
 * Core type definitions for Oystraz
 */

// User types
export interface User {
  id: number;
  email: string;
  username: string;
  full_name?: string;
  age?: number;
  gender?: string;
  height?: number; // in cm
  weight?: number; // in kg
  goal?: string; // lose_weight, maintain, gain_muscle, improve_health
  created_at: string;
  updated_at: string;
}

// Character health metrics
export interface CharacterState {
  stamina: number; // 0-100
  energy: number; // 0-100
  nutrition: number; // 0-100
  mood: number; // 0-100
  stress: number; // 0-100
  level: number;
  experience: number;
  bodyType: 'thin' | 'normal' | 'overweight' | 'obese';
  emotionalState: 'happy' | 'normal' | 'tired' | 'stressed' | 'angry';
}

// Meal types
export interface FoodItem {
  id: string;
  name: string;
  calories: number;
  protein: number; // in grams
  carbs: number; // in grams
  fat: number; // in grams
  servingSize: string;
}

export interface Meal {
  id: string;
  userId: string;
  datetime: string;
  mealType: 'breakfast' | 'lunch' | 'dinner' | 'snack';
  foodItems: FoodItem[];
  totalCalories: number;
  totalProtein: number;
  totalCarbs: number;
  totalFat: number;
}

// Diet Log (from backend API)
export interface DietLog {
  id: number;
  user_id: number;
  food_name: string;
  meal_type?: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  fiber: number;
  serving_size: number;
  serving_unit: string;
  notes?: string;
  logged_at: string;
  created_at: string;
}

// Exercise types
export interface Exercise {
  id: string;
  userId: string;
  datetime: string;
  exerciseType: string;
  duration: number; // in minutes
  intensity: 'low' | 'medium' | 'high';
  caloriesBurned: number;
}

// Exercise Log (from backend API)
export interface ExerciseLog {
  id: number;
  user_id: number;
  activity_name: string;
  activity_type?: string;
  duration_minutes: number;
  intensity: string;
  calories_burned: number;
  distance?: number;
  distance_unit: string;
  heart_rate_avg?: number;
  steps?: number;
  notes?: string;
  logged_at: string;
  created_at: string;
}

// Sleep types
export interface Sleep {
  id: string;
  userId: string;
  date: string;
  bedtime: string;
  wakeTime: string;
  duration: number; // in hours
  qualityScore: number; // 0-100
}

// Sleep Log (from backend API)
export interface SleepLog {
  id: number;
  user_id: number;
  sleep_start: string;
  sleep_end: string;
  duration_hours: number;
  quality: string;
  quality_score?: number;
  deep_sleep_minutes?: number;
  light_sleep_minutes?: number;
  rem_sleep_minutes?: number;
  awake_minutes?: number;
  interruptions: number;
  notes?: string;
  logged_at: string;
  created_at: string;
}

// Workplace event types
export interface WorkEvent {
  id: string;
  eventType: string;
  title: string;
  description: string;
  availableChoices: WorkChoice[];
  characterStateBefore: CharacterState;
}

export interface WorkChoice {
  id: string;
  text: string;
  emoji: string;
  requires?: Partial<CharacterState>; // Minimum requirements
  consequences: Partial<CharacterState>; // Changes to apply
}

export interface WorkEventResult {
  eventId: string;
  choice: WorkChoice;
  stateAfter: CharacterState;
  message: string;
}

// Achievement types
export interface Achievement {
  id: string;
  type: string;
  title: string;
  description: string;
  icon: string;
  unlockedAt?: string;
}

// AI Chat types
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

// API Response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Daily summary
export interface DailySummary {
  date: string;
  meals: Meal[];
  exercises: Exercise[];
  sleep?: Sleep;
  workEvents: WorkEventResult[];
  characterState: CharacterState;
  healthTrend: 'improving' | 'stable' | 'declining';
}
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": false,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="frontend/src/config/api.ts">
/**
 * API configuration
 */

export const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

export const API_ENDPOINTS = {
  // Authentication
  register: '/auth/register',
  login: '/auth/login',

  // User
  userMe: '/users/me',

  // Character
  character: '/character',

  // Health Tracking
  diet: '/diet',
  exercise: '/exercise',
  sleep: '/sleep',

  // AI Assistant
  pearlChat: '/assistant/pearl/chat',
  aiAdvice: '/assistant/advice',
  workplaceScenario: '/assistant/workplace-scenario',
  foodSearch: '/assistant/food-search',
  foodDetails: (fdcId: number) => `/assistant/food/${fdcId}`,
} as const;
</file>

<file path="frontend/src/pages/Stats.tsx">
/**
 * Stats Page
 * Data visualization and reports
 */

import { useState, useEffect } from 'react';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  Card,
  CardContent,
  ToggleButtonGroup,
  ToggleButton,
  CircularProgress,
} from '@mui/material';
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  AreaChart,
  Area,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import { getDietLogs, getExerciseLogs, getSleepLogs } from '../services/healthService';
import type { DietLog, ExerciseLog, SleepLog } from '../types';

interface DailyStats {
  date: string;
  calories: number;
  exercise: number;
  sleep: number;
  sleepQuality: number;
}

interface TimeAllocation {
  name: string;
  value: number;
  color: string;
  [key: string]: string | number;
}

export default function Stats() {
  const [timeRange, setTimeRange] = useState<'7' | '30'>('7');
  const [loading, setLoading] = useState(true);
  const [dailyStats, setDailyStats] = useState<DailyStats[]>([]);
  const [totalStats, setTotalStats] = useState({
    avgCalories: 0,
    avgExercise: 0,
    avgSleep: 0,
    totalWorkouts: 0,
  });
  const [timeAllocation, setTimeAllocation] = useState<TimeAllocation[]>([]);

  useEffect(() => {
    loadStats();
  }, [timeRange]);

  const loadStats = async () => {
    try {
      setLoading(true);
      const days = parseInt(timeRange);

      // Fetch all health logs
      const [dietLogs, exerciseLogs, sleepLogs] = await Promise.all([
        getDietLogs(days),
        getExerciseLogs(days),
        getSleepLogs(days),
      ]);

      // Process data by date
      const statsMap = new Map<string, DailyStats>();

      // Initialize dates for the past N days
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        statsMap.set(dateStr, {
          date: dateStr,
          calories: 0,
          exercise: 0,
          sleep: 0,
          sleepQuality: 0,
        });
      }

      // Aggregate diet logs
      dietLogs.forEach((log: DietLog) => {
        const date = new Date(log.logged_at).toISOString().split('T')[0];
        const stats = statsMap.get(date);
        if (stats) {
          stats.calories += log.calories || 0;
        }
      });

      // Aggregate exercise logs
      exerciseLogs.forEach((log: ExerciseLog) => {
        const date = new Date(log.logged_at).toISOString().split('T')[0];
        const stats = statsMap.get(date);
        if (stats) {
          stats.exercise += log.calories_burned || 0;
        }
      });

      // Aggregate sleep logs
      sleepLogs.forEach((log: SleepLog) => {
        const date = new Date(log.logged_at).toISOString().split('T')[0];
        const stats = statsMap.get(date);
        if (stats) {
          stats.sleep = log.duration_hours || 0;
          stats.sleepQuality = log.quality_score || 0;
        }
      });

      // Convert map to array and sort by date
      const statsArray = Array.from(statsMap.values()).sort(
        (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
      );

      // Format dates for display (MM/DD)
      const formattedStats = statsArray.map((stat) => ({
        ...stat,
        date: new Date(stat.date).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
        }),
      }));

      setDailyStats(formattedStats);

      // Calculate totals
      const totalCalories = formattedStats.reduce((sum, day) => sum + day.calories, 0);
      const totalExercise = formattedStats.reduce((sum, day) => sum + day.exercise, 0);
      const totalSleep = formattedStats.reduce((sum, day) => sum + day.sleep, 0);
      // Use actual days with recorded data for more accurate averages
      const daysWithData = formattedStats.filter((day) => day.calories > 0 || day.exercise > 0 || day.sleep > 0).length || 1;

      setTotalStats({
        avgCalories: Math.round(totalCalories / daysWithData),
        avgExercise: Math.round(totalExercise / daysWithData),
        avgSleep: parseFloat((totalSleep / daysWithData).toFixed(1)),
        totalWorkouts: exerciseLogs.length,
      });

      // Calculate time allocation for pie chart (use daysWithData for accurate averages)
      const avgSleepHours = totalSleep / daysWithData;

      // Calculate average exercise time in hours
      const totalExerciseMinutes = exerciseLogs.reduce((sum, log) => sum + (log.duration_minutes || 0), 0);
      const avgExerciseHours = totalExerciseMinutes / daysWithData / 60;

      // Assume 8 hours of work per day (can be made configurable later)
      const avgWorkHours = 8;

      // Calculate leisure time
      const avgLeisureHours = Math.max(0, 24 - avgSleepHours - avgExerciseHours - avgWorkHours);

      setTimeAllocation([
        { name: 'Sleep', value: parseFloat(avgSleepHours.toFixed(1)), color: '#8884d8' },
        { name: 'Work', value: parseFloat(avgWorkHours.toFixed(1)), color: '#82ca9d' },
        { name: 'Exercise', value: parseFloat(avgExerciseHours.toFixed(1)), color: '#ffc658' },
        { name: 'Leisure', value: parseFloat(avgLeisureHours.toFixed(1)), color: '#ff7c7c' },
      ]);
    } catch (error) {
      console.error('Failed to load stats:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Container maxWidth="lg">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '60vh' }}>
          <CircularProgress />
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg">
      <Box sx={{ mt: { xs: 2, sm: 3, md: 4 }, mb: { xs: 2, sm: 3, md: 4 }, px: { xs: 1, sm: 2 } }}>
        <Box
          sx={{
            display: 'flex',
            flexDirection: { xs: 'column', sm: 'row' },
            justifyContent: 'space-between',
            alignItems: { xs: 'flex-start', sm: 'center' },
            mb: { xs: 2, sm: 3 },
            gap: 2,
          }}
        >
          <Typography
            variant="h3"
            component="h1"
            sx={{ fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' } }}
          >
            Your Statistics
          </Typography>
          <ToggleButtonGroup
            value={timeRange}
            exclusive
            onChange={(_, value) => value && setTimeRange(value)}
            size="small"
            sx={{ alignSelf: { xs: 'flex-start', sm: 'center' } }}
          >
            <ToggleButton value="7">7 Days</ToggleButton>
            <ToggleButton value="30">30 Days</ToggleButton>
          </ToggleButtonGroup>
        </Box>

        {/* Summary Cards */}
        <Grid container spacing={{ xs: 2, sm: 2, md: 3 }} sx={{ mb: { xs: 2, sm: 3, md: 4 } }}>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent>
                <Typography color="text.secondary" gutterBottom>
                  Avg Calories/Day
                </Typography>
                <Typography variant="h4">{totalStats.avgCalories}</Typography>
                <Typography variant="body2" color="text.secondary">
                  kcal
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent>
                <Typography color="text.secondary" gutterBottom>
                  Avg Exercise/Day
                </Typography>
                <Typography variant="h4">{totalStats.avgExercise}</Typography>
                <Typography variant="body2" color="text.secondary">
                  kcal burned
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent>
                <Typography color="text.secondary" gutterBottom>
                  Avg Sleep/Night
                </Typography>
                <Typography variant="h4">{totalStats.avgSleep}</Typography>
                <Typography variant="body2" color="text.secondary">
                  hours
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card>
              <CardContent>
                <Typography color="text.secondary" gutterBottom>
                  Total Workouts
                </Typography>
                <Typography variant="h4">{totalStats.totalWorkouts}</Typography>
                <Typography variant="body2" color="text.secondary">
                  sessions
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        {/* Time Allocation Pie Chart */}
        <Paper elevation={2} sx={{ p: { xs: 2, sm: 2, md: 3 }, mb: { xs: 2, sm: 2, md: 3 } }}>
          <Typography variant="h6" gutterBottom>
            Daily Time Allocation (24 Hours)
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', overflow: 'hidden' }}>
            <ResponsiveContainer width="100%" height={350}>
              <PieChart>
                <Pie
                  data={timeAllocation}
                  cx="50%"
                  cy="50%"
                  labelLine={true}
                  label={({ name, value }) => `${name}: ${value}h`}
                  outerRadius={100}
                  fill="#8884d8"
                  dataKey="value"
                >
                  {timeAllocation.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
                <Tooltip formatter={(value) => `${value} hours`} />
                <Legend />
              </PieChart>
            </ResponsiveContainer>
          </Box>
        </Paper>

        {/* Calories Chart */}
        <Paper elevation={2} sx={{ p: { xs: 2, sm: 2, md: 3 }, mb: { xs: 2, sm: 2, md: 3 } }}>
          <Typography variant="h6" gutterBottom>
            Daily Calorie Intake
          </Typography>
          <ResponsiveContainer width="100%" height={250}>
            <AreaChart data={dailyStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Area
                type="monotone"
                dataKey="calories"
                stroke="#8884d8"
                fill="#8884d8"
                fillOpacity={0.6}
                name="Calories (kcal)"
              />
            </AreaChart>
          </ResponsiveContainer>
        </Paper>

        {/* Exercise Chart */}
        <Paper elevation={2} sx={{ p: { xs: 2, sm: 2, md: 3 }, mb: { xs: 2, sm: 2, md: 3 } }}>
          <Typography variant="h6" gutterBottom>
            Daily Exercise Activity
          </Typography>
          <ResponsiveContainer width="100%" height={250}>
            <BarChart data={dailyStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="exercise" fill="#82ca9d" name="Calories Burned (kcal)" />
            </BarChart>
          </ResponsiveContainer>
        </Paper>

        {/* Sleep Chart */}
        <Paper elevation={2} sx={{ p: { xs: 2, sm: 2, md: 3 }, mb: { xs: 2, sm: 2, md: 3 } }}>
          <Typography variant="h6" gutterBottom>
            Sleep Duration & Quality
          </Typography>
          <ResponsiveContainer width="100%" height={250}>
            <LineChart data={dailyStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis yAxisId="left" />
              <YAxis yAxisId="right" orientation="right" domain={[0, 5]} />
              <Tooltip />
              <Legend />
              <Line
                yAxisId="left"
                type="monotone"
                dataKey="sleep"
                stroke="#8884d8"
                strokeWidth={2}
                name="Sleep (hours)"
              />
              <Line
                yAxisId="right"
                type="monotone"
                dataKey="sleepQuality"
                stroke="#82ca9d"
                strokeWidth={2}
                name="Quality (0-5)"
              />
            </LineChart>
          </ResponsiveContainer>
        </Paper>

        {/* Net Calories Chart */}
        <Paper elevation={2} sx={{ p: { xs: 2, sm: 2, md: 3 } }}>
          <Typography variant="h6" gutterBottom>
            Net Calories (Intake - Exercise)
          </Typography>
          <ResponsiveContainer width="100%" height={250}>
            <LineChart data={dailyStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line
                type="monotone"
                dataKey="calories"
                stroke="#8884d8"
                strokeWidth={2}
                name="Intake (kcal)"
              />
              <Line
                type="monotone"
                dataKey="exercise"
                stroke="#ff7300"
                strokeWidth={2}
                name="Burned (kcal)"
              />
            </LineChart>
          </ResponsiveContainer>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

<file path="frontend/src/pages/Track.tsx">
/**
 * Track Page
 * Page for logging food, exercise, and sleep
 */

import { useState } from 'react';
import {
  Container,
  Typography,
  Box,
  Tabs,
  Tab,
  Paper,
} from '@mui/material';
import RestaurantIcon from '@mui/icons-material/Restaurant';
import FitnessCenterIcon from '@mui/icons-material/FitnessCenter';
import BedtimeIcon from '@mui/icons-material/Bedtime';
import DietLog from '../components/Track/DietLog';
import ExerciseLog from '../components/Track/ExerciseLog';
import SleepLog from '../components/Track/SleepLog';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`track-tabpanel-${index}`}
      aria-labelledby={`track-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: { xs: 2, sm: 3 }, px: { xs: 1, sm: 2 } }}>{children}</Box>}
    </div>
  );
}

export default function Track() {
  const [activeTab, setActiveTab] = useState(0);

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  return (
    <Container maxWidth="lg">
      <Box sx={{ mt: { xs: 2, sm: 3, md: 4 }, mb: { xs: 2, sm: 3, md: 4 }, px: { xs: 1, sm: 2 } }}>
        <Typography
          variant="h3"
          component="h1"
          gutterBottom
          sx={{ fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' } }}
        >
          Track Your Health
        </Typography>
        <Typography
          variant="subtitle1"
          color="text.secondary"
          gutterBottom
          sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
        >
          Log your meals, exercise, and sleep to keep your character healthy
        </Typography>

        <Paper sx={{ mt: { xs: 2, sm: 3 } }}>
          <Tabs
            value={activeTab}
            onChange={handleTabChange}
            aria-label="health tracking tabs"
            variant="fullWidth"
            sx={{
              borderBottom: 1,
              borderColor: 'divider',
              '& .MuiTab-root': {
                fontSize: { xs: '0.75rem', sm: '0.875rem' },
                minHeight: { xs: 64, sm: 72 },
              }
            }}
          >
            <Tab
              icon={<RestaurantIcon sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }} />}
              label="Diet"
              id="track-tab-0"
              aria-controls="track-tabpanel-0"
            />
            <Tab
              icon={<FitnessCenterIcon sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }} />}
              label="Exercise"
              id="track-tab-1"
              aria-controls="track-tabpanel-1"
            />
            <Tab
              icon={<BedtimeIcon sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }} />}
              label="Sleep"
              id="track-tab-2"
              aria-controls="track-tabpanel-2"
            />
          </Tabs>

          <TabPanel value={activeTab} index={0}>
            <DietLog />
          </TabPanel>
          <TabPanel value={activeTab} index={1}>
            <ExerciseLog />
          </TabPanel>
          <TabPanel value={activeTab} index={2}>
            <SleepLog />
          </TabPanel>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

<file path="frontend/src/pages/Work.tsx">
/**
 * Work Simulation Page
 * Interactive workplace scenarios based on health state
 */

import { useState, useEffect } from 'react';
import {
  Container,
  Typography,
  Box,
  Button,
  Paper,
  Grid,
  LinearProgress,
  Chip,
  Card,
  CardContent,
  CardActions,
  Alert,
  CircularProgress,
} from '@mui/material';
import WorkIcon from '@mui/icons-material/Work';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { useCharacterStore } from '../store/characterStore';
import { getCharacter, updateCharacter } from '../services/characterService';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { generateWorkScenario } from '../services/aiService'; // TODO: Use for AI-generated scenarios

interface ScenarioChoice {
  id: number;
  text: string;
  emoji: string;
  effects: {
    stamina?: number;
    energy?: number;
    nutrition?: number;
    mood?: number;
    stress?: number;
    experience?: number;
  };
}

interface WorkScenario {
  title: string;
  description: string;
  situation: string;
  choices: ScenarioChoice[];
}

export default function Work() {
  const { character, setCharacter } = useCharacterStore();
  const [scenario, setScenario] = useState<WorkScenario | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<string | null>(null);
  const [scenarioHistory, setScenarioHistory] = useState<number>(0);

  useEffect(() => {
    loadCharacter();
  }, []);

  const loadCharacter = async () => {
    try {
      const data = await getCharacter();
      setCharacter({
        stamina: data.stamina,
        energy: data.energy,
        nutrition: data.nutrition,
        mood: data.mood,
        stress: data.stress,
        level: data.level,
        experience: data.experience,
        bodyType: data.body_type as any,
        emotionalState: data.emotional_state as any,
      });
    } catch (error) {
      console.error('Failed to load character:', error);
    }
  };

  const generateNewScenario = async () => {
    if (!character) return;

    setIsLoading(true);
    setResult(null);

    try {
      // For now, use fallback scenarios based on character health state
      // TODO: Enhance Gemini API to return structured scenario data
      const newScenario: WorkScenario = getFallbackScenario(character);

      setScenario(newScenario);
    } catch (error) {
      console.error('Failed to generate scenario:', error);
      // Fallback scenario if API fails
      setScenario(getFallbackScenario(character));
    } finally {
      setIsLoading(false);
    }
  };

  const handleChoice = async (choice: ScenarioChoice) => {
    if (!character) return;

    setIsLoading(true);

    try {
      // Calculate new stats
      const newStats = {
        stamina: Math.max(0, Math.min(100, character.stamina + (choice.effects.stamina || 0))),
        energy: Math.max(0, Math.min(100, character.energy + (choice.effects.energy || 0))),
        nutrition: Math.max(0, Math.min(100, character.nutrition + (choice.effects.nutrition || 0))),
        mood: Math.max(0, Math.min(100, character.mood + (choice.effects.mood || 0))),
        stress: Math.max(0, Math.min(100, character.stress + (choice.effects.stress || 0))),
      };

      const newExperience = character.experience + (choice.effects.experience || 0);
      const newLevel = Math.floor(newExperience / 100) + 1;

      // Update character on backend
      await updateCharacter(newStats);

      // Update local state
      setCharacter({
        ...character,
        ...newStats,
        experience: newExperience,
        level: newLevel,
      });

      // Show result
      setResult(getChoiceResult(choice));
      setScenarioHistory(scenarioHistory + 1);
      setScenario(null);
    } catch (error) {
      console.error('Failed to update character:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // TODO: Use this function when implementing AI-generated scenarios with dynamic titles
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const getScenarioTitle = (char: any): string => {
    if (char.energy < 30) return "üò¥ Low Energy Alert";
    if (char.stress > 70) return "üò∞ High Pressure Situation";
    if (char.mood < 40) return "üòî Challenging Moment";
    if (char.stamina < 40) return "üí§ Fatigue Setting In";
    return "üè¢ Another Day at Work";
  };

  const getFallbackScenario = (char: any): WorkScenario => {
    if (char.stress > 60) {
      return {
        title: "üò∞ Tight Deadline Pressure",
        description: "Your boss just moved up the deadline for a major project.",
        situation: "The project that was due next week is now due tomorrow. How do you respond?",
        choices: [
          {
            id: 1,
            text: "Pull an all-nighter to finish it",
            emoji: "üåô",
            effects: { stamina: -25, energy: -30, stress: 15, mood: -10, experience: 35 },
          },
          {
            id: 2,
            text: "Negotiate a more realistic timeline",
            emoji: "üí¨",
            effects: { stamina: -5, energy: -10, stress: -10, mood: 10, experience: 45 },
          },
          {
            id: 3,
            text: "Focus on core features only",
            emoji: "üéØ",
            effects: { stamina: -10, energy: -15, stress: 5, mood: 5, experience: 40 },
          },
          {
            id: 4,
            text: "Get team members to help",
            emoji: "üë•",
            effects: { stamina: -5, energy: -10, stress: -5, mood: 15, experience: 30 },
          },
        ],
      };
    }

    return {
      title: "üè¢ Regular Workday",
      description: "Just another day at the office.",
      situation: "You have a normal workload today. How do you approach it?",
      choices: [
        {
          id: 1,
          text: "Hustle and get everything done quickly",
          emoji: "‚ö°",
          effects: { stamina: -15, energy: -20, stress: 10, mood: 5, experience: 30 },
        },
        {
          id: 2,
          text: "Take it steady and pace yourself",
          emoji: "üö∂",
          effects: { stamina: -8, energy: -10, stress: -5, mood: 10, experience: 25 },
        },
        {
          id: 3,
          text: "Take breaks and maintain work-life balance",
          emoji: "‚öñÔ∏è",
          effects: { stamina: 5, energy: 5, stress: -15, mood: 20, experience: 20 },
        },
        {
          id: 4,
          text: "Slack off a bit (Êë∏È±º mode)",
          emoji: "üêü",
          effects: { stamina: 10, energy: 15, stress: -20, mood: 15, experience: 10 },
        },
      ],
    };
  };

  const getChoiceResult = (choice: ScenarioChoice): string => {
    const results = [
      `You chose to ${choice.text.toLowerCase()}. ${choice.emoji}`,
      "Your choice has affected your wellbeing.",
      choice.effects.experience ? `+${choice.effects.experience} XP gained!` : "",
    ];
    return results.filter(Boolean).join(" ");
  };

  if (!character) {
    return (
      <Container maxWidth="lg">
        <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}>
          <CircularProgress />
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg">
      <Box sx={{ mt: { xs: 2, sm: 3, md: 4 }, mb: { xs: 2, sm: 3, md: 4 }, px: { xs: 1, sm: 2 } }}>
        <Typography
          variant="h3"
          component="h1"
          gutterBottom
          sx={{ fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' } }}
        >
          Work Simulator
        </Typography>
        <Typography
          variant="subtitle1"
          color="text.secondary"
          gutterBottom
          sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
        >
          Navigate workplace challenges - your health affects your performance
        </Typography>

        {/* Character Status */}
        <Paper sx={{ p: { xs: 2, sm: 2, md: 3 }, mt: { xs: 2, sm: 3 }, mb: { xs: 2, sm: 3 } }}>
          <Grid container spacing={2}>
            <Grid size={{ xs: 12, md: 6 }}>
              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                  <Typography variant="body2">üí™ Stamina</Typography>
                  <Typography variant="body2">{character.stamina}/100</Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={character.stamina}
                  sx={{ height: 8, borderRadius: 1 }}
                />
              </Box>

              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                  <Typography variant="body2">‚ö° Energy</Typography>
                  <Typography variant="body2">{character.energy}/100</Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={character.energy}
                  sx={{ height: 8, borderRadius: 1 }}
                  color="secondary"
                />
              </Box>

              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                  <Typography variant="body2">üòä Mood</Typography>
                  <Typography variant="body2">{character.mood}/100</Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={character.mood}
                  sx={{ height: 8, borderRadius: 1 }}
                  color="success"
                />
              </Box>
            </Grid>

            <Grid size={{ xs: 12, md: 6 }}>
              <Box sx={{ mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                  <Typography variant="body2">üò∞ Stress</Typography>
                  <Typography variant="body2">{character.stress}/100</Typography>
                </Box>
                <LinearProgress
                  variant="determinate"
                  value={character.stress}
                  sx={{ height: 8, borderRadius: 1 }}
                  color="error"
                />
              </Box>

              <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mt: 3 }}>
                <Chip
                  icon={<AutoAwesomeIcon />}
                  label={`Level ${character.level}`}
                  color="primary"
                  variant="outlined"
                />
                <Box sx={{ flex: 1 }}>
                  <Typography variant="caption" color="text.secondary">
                    XP: {character.experience % 100}/100
                  </Typography>
                  <LinearProgress
                    variant="determinate"
                    value={(character.experience % 100)}
                    sx={{ height: 6, borderRadius: 1, mt: 0.5 }}
                  />
                </Box>
              </Box>

              <Typography variant="caption" color="text.secondary" sx={{ mt: 2, display: 'block' }}>
                Scenarios completed: {scenarioHistory}
              </Typography>
            </Grid>
          </Grid>
        </Paper>

        {/* Result Message */}
        {result && (
          <Alert severity="success" sx={{ mb: 3 }} onClose={() => setResult(null)}>
            {result}
          </Alert>
        )}

        {/* Scenario or Generate Button */}
        {!scenario ? (
          <Box sx={{ textAlign: 'center', py: { xs: 4, sm: 5, md: 6 }, px: { xs: 2, sm: 0 } }}>
            <WorkIcon sx={{ fontSize: { xs: 60, sm: 70, md: 80 }, color: 'text.secondary', mb: 2 }} />
            <Typography
              variant="h5"
              gutterBottom
              sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }}
            >
              Ready for a workplace challenge?
            </Typography>
            <Typography
              color="text.secondary"
              paragraph
              sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
            >
              Your health state will influence the scenarios you face
            </Typography>
            <Button
              variant="contained"
              size="large"
              startIcon={<AutoAwesomeIcon />}
              onClick={generateNewScenario}
              disabled={isLoading}
              sx={{
                mt: 2,
                fontSize: { xs: '1rem', sm: '1.1rem' },
                py: { xs: 1.25, sm: 1.5 },
                px: { xs: 3, sm: 4 }
              }}
            >
              {isLoading ? 'Generating...' : 'Generate Scenario'}
            </Button>
          </Box>
        ) : (
          <Paper sx={{ p: { xs: 2, sm: 3, md: 4 } }}>
            <Typography
              variant="h4"
              gutterBottom
              sx={{
                display: 'flex',
                alignItems: 'center',
                gap: 1,
                fontSize: { xs: '1.5rem', sm: '2rem', md: '2.125rem' }
              }}
            >
              {scenario.title}
            </Typography>
            <Typography
              variant="body1"
              color="text.secondary"
              paragraph
              sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
            >
              {scenario.description}
            </Typography>
            <Typography
              variant="h6"
              sx={{
                mt: { xs: 2, sm: 3 },
                mb: 2,
                fontSize: { xs: '1.125rem', sm: '1.25rem' }
              }}
            >
              {scenario.situation}
            </Typography>

            <Grid container spacing={{ xs: 1.5, sm: 2 }} sx={{ mt: { xs: 1, sm: 2 } }}>
              {scenario.choices.map((choice) => (
                <Grid size={{ xs: 12, sm: 6 }} key={choice.id}>
                  <Card
                    variant="outlined"
                    sx={{
                      height: '100%',
                      cursor: isLoading ? 'not-allowed' : 'pointer',
                      '&:hover': isLoading ? {} : {
                        borderColor: 'primary.main',
                        boxShadow: 2,
                      },
                    }}
                  >
                    <CardContent sx={{ pb: 1 }}>
                      <Typography
                        variant="h5"
                        gutterBottom
                        sx={{ fontSize: { xs: '1.75rem', sm: '2rem' } }}
                      >
                        {choice.emoji}
                      </Typography>
                      <Typography
                        variant="subtitle1"
                        gutterBottom
                        sx={{ fontSize: { xs: '0.9375rem', sm: '1rem' } }}
                      >
                        {choice.text}
                      </Typography>
                      <Box sx={{ mt: { xs: 1.5, sm: 2 }, display: 'flex', gap: 0.75, flexWrap: 'wrap' }}>
                        {Object.entries(choice.effects).map(([key, value]) => {
                          if (key === 'experience') {
                            return (
                              <Chip
                                key={key}
                                label={`+${value} XP`}
                                size="small"
                                color="primary"
                                variant="outlined"
                              />
                            );
                          }
                          const icon = key === 'stamina' ? 'üí™' :
                                      key === 'energy' ? '‚ö°' :
                                      key === 'mood' ? 'üòä' :
                                      key === 'stress' ? 'üò∞' : 'üçé';
                          return (
                            <Chip
                              key={key}
                              label={`${icon} ${value > 0 ? '+' : ''}${value}`}
                              size="small"
                              color={value < 0 ? 'error' : 'success'}
                              variant="outlined"
                            />
                          );
                        })}
                      </Box>
                    </CardContent>
                    <CardActions>
                      <Button
                        fullWidth
                        variant="contained"
                        onClick={() => handleChoice(choice)}
                        disabled={isLoading}
                      >
                        Choose This
                      </Button>
                    </CardActions>
                  </Card>
                </Grid>
              ))}
            </Grid>
          </Paper>
        )}
      </Box>
    </Container>
  );
}
</file>

<file path="README.md">
# Oystraz - Life Orchestration Through Health

> **"The world is your oyster; Orchestrate your life through wellness."**
>
> A gamified health tracking and life simulation app where your real-world choices (diet, sleep, exercise) directly influence your virtual character's performance at work and in life.

**Google Gemini 3 Hackathon Project**

---

## üéÆ Project Vision

**Oystraz** merges two powerful metaphors:
- **Oyster** - "The world is your oyster" - life is full of opportunities waiting to be seized
- **Orchestra** - The art of coordinating complex elements into harmonious performance

The core philosophy: **By orchestrating your physical wellness, you gain control over your work and life.**

Oystraz is not just another health tracker - it's a **stress-relief simulator** that gamifies wellness while providing a safe space to express workplace frustrations. Your virtual character mirrors your real health data, and its workplace behavior reflects your physical and mental state.

### Core Principles
- üçé **Data-Driven Wellness** - Powered by USDA FoodData Central (600,000+ foods)
- üèÉ **Scientific Activity Tracking** - Accurate calorie expenditure calculations
- üòä **Emotional Intelligence** - Dynamic workplace scenarios based on health metrics
- üíº **Work-Life Balance** - Anti-hustle culture, pro-taking-breaks philosophy
- ü§ñ **AI Companion (Pearl)** - Gemini-powered assistant with personality and food science expertise

---

## ‚úÖ Current Implementation Status

### Completed Features (MVP Ready)

#### 1. **Health Tracking System** ‚úÖ
- ‚úÖ **Diet Logging** - USDA food search (600k+ items), serving size customization, calorie tracking
- ‚úÖ **Exercise Recording** - 13 activity types, 4 intensity levels, automatic calorie burn calculation
- ‚úÖ **Sleep Tracking** - Duration logging, 5-star quality rating, 7-day history

#### 2. **Character System** ‚úÖ
- ‚úÖ Character state management (stamina, energy, nutrition, mood, stress)
- ‚úÖ Real-time attribute updates based on health logs
- ‚úÖ Level and experience progression system
- ‚úÖ Body type and emotional state tracking

#### 3. **Work Simulator** ‚úÖ
- ‚úÖ Interactive workplace scenario engine
- ‚úÖ Health-based event triggering
- ‚úÖ 4-choice decision system with stat impacts
- ‚úÖ Fallback scenarios for varied gameplay

#### 4. **Data Visualization** ‚úÖ
- ‚úÖ Interactive statistics dashboard
- ‚úÖ 7-day and 30-day trend analysis
- ‚úÖ Multiple chart types (area, bar, line, pie)
- ‚úÖ Summary cards (avg calories, exercise, sleep, workouts)
- ‚úÖ Time allocation pie chart (sleep/work/exercise/leisure)

#### 5. **Profile Management** ‚úÖ
- ‚úÖ User information editing (height, weight, age, gender, health goals)
- ‚úÖ Form validation and error handling
- ‚úÖ Real-time updates to user store

#### 6. **AI Assistant (Pearl)** ‚úÖ
- ‚úÖ Gemini 2.5 Flash integration
- ‚úÖ Contextual health advice
- ‚úÖ Personality-driven responses (humorous, reliable, food-passionate)
- ‚úÖ Conversation history support

#### 7. **Authentication & Security** ‚úÖ
- ‚úÖ JWT-based authentication
- ‚úÖ User registration and login
- ‚úÖ Password hashing with bcrypt
- ‚úÖ Protected API routes

---

## ü§ñ Meet Pearl - Your AI Health Companion

**Pearl (ÁèçÁè†)** is not your typical wellness coach. She's a Food Science major who genuinely loves food and has a dry sense of humor.

### Pearl's Personality:
- **Reliable but Chill** - Gives solid, researched advice without the corporate wellness BS
- **Food Enthusiast** - Lights up when discussing nutrition, gets excited about ingredients and food chemistry
- **Witty & Deadpan** - Drops dad jokes and puns naturally, sometimes you're not sure if she's joking
- **Anti-Hustle Culture** - Believes in work-life balance, taking real breaks, and logging off at 5pm
- **Direct Communicator** - No filler words, gets straight to the point in 2-3 sentences

### Example Interactions:
```
User: "I'm so stressed from work"
Pearl: "Your stress is at 80/100. That's not sustainable - unless you're
trying to speedrun burnout. Take a real break, not just scrolling Twitter
for 5 minutes."

User: "Just had some rice for lunch"
Pearl: "Rice! Great choice. White or brown? Fun fact: cooling cooked rice
creates resistant starch - feeds your gut bacteria. Meal prep enthusiasts
figured that out by accident."

User: "Haven't eaten all day"
Pearl: "Can't run on empty. Your body's not a startup that runs on vibes
and cold brew. What's the fastest thing you can grab right now?"
```

---

## üèóÔ∏è Technical Architecture

### Technology Stack

#### Frontend
```
‚îú‚îÄ React 19 + TypeScript
‚îú‚îÄ Material-UI v6 (MUI)
‚îú‚îÄ State Management: Zustand
‚îú‚îÄ Routing: React Router v7
‚îú‚îÄ Charts: Recharts
‚îú‚îÄ Build Tool: Vite
‚îî‚îÄ Icons: @mui/icons-material
```

#### Backend
```
‚îú‚îÄ FastAPI (Python 3.11+)
‚îú‚îÄ Database: PostgreSQL
‚îú‚îÄ ORM: SQLAlchemy 2.0
‚îú‚îÄ Authentication: JWT (python-jose)
‚îú‚îÄ Password Hashing: passlib with bcrypt
‚îî‚îÄ API Docs: Auto-generated (FastAPI/Swagger)
```

#### AI & Data Sources
```
‚îú‚îÄ Google Gemini 2.5 Flash (chat & advice)
‚îú‚îÄ USDA FoodData Central API (nutritional database)
‚îú‚îÄ Custom calorie calculation algorithms
‚îî‚îÄ Food science-based nutrition parsing
```

### Project Structure (Actual)

```
oystraz/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Track/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DietLog.tsx       # USDA food search & logging
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExerciseLog.tsx   # Exercise tracking
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SleepLog.tsx      # Sleep tracking
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Work/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ WorkScenario.tsx  # Workplace simulator
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx              # Character dashboard
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Track.tsx             # Health tracking hub
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Work.tsx              # Work simulation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Stats.tsx             # Data visualization ‚≠ê
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Profile.tsx           # User settings
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                # Axios client
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authService.ts        # Auth APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ characterService.ts   # Character APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ healthService.ts      # Health tracking APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ aiService.ts          # Pearl chat API
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pearlService.ts       # Pearl helpers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ userStore.ts          # User state
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ characterStore.ts     # Character state
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.ts              # TypeScript definitions
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                   # FastAPI app entry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py                 # Environment config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py               # DB connection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/                   # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ character.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diet_log.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exercise_log.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sleep_log.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/                  # Pydantic schemas
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ character.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diet.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exercise.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sleep.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routers/                  # API routes
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py               # Register/login
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py               # User management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ character.py          # Character endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ diet.py               # Diet logging
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exercise.py           # Exercise logging
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sleep.py              # Sleep logging
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ assistant.py          # Pearl chat & USDA search ‚≠ê
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ auth.py               # JWT logic
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ gemini.py             # Gemini API client ‚≠ê
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ usda.py               # USDA API client ‚≠ê
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ
‚îî‚îÄ‚îÄ README.md
```

### System Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              User Interface (React)              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ  Track   ‚îÇ  ‚îÇ   Work   ‚îÇ  ‚îÇ  Stats   ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ (Health) ‚îÇ  ‚îÇ (Simulate‚îÇ  ‚îÇ(Visualize‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ HTTP/REST
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           FastAPI Backend (Python)               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ   Auth   ‚îÇ  ‚îÇ Character‚îÇ  ‚îÇ   AI     ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ  Routes  ‚îÇ  ‚îÇ  Routes  ‚îÇ  ‚îÇ Assistant‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ             ‚îÇ               ‚îÇ
        ‚ñº             ‚ñº               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇPostgreSQL‚îÇ  ‚îÇ  Gemini  ‚îÇ  ‚îÇ  USDA FoodData   ‚îÇ
‚îÇ Database ‚îÇ  ‚îÇ   API    ‚îÇ  ‚îÇ  Central API     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìä Database Schema

```sql
-- Users
users:
  id, username, email, hashed_password,
  full_name, age, gender, height, weight, goal,
  created_at, updated_at

-- Characters (one per user)
characters:
  id, user_id,
  stamina, energy, nutrition, mood, stress,
  level, experience,
  body_type, emotional_state,
  created_at, updated_at

-- Diet Logs
diet_logs:
  id, user_id,
  food_name, meal_type,
  calories, protein, carbs, fat, fiber,
  serving_size, serving_unit,
  notes, logged_at

-- Exercise Logs
exercise_logs:
  id, user_id,
  activity_name, activity_type,
  duration_minutes, intensity,
  calories_burned, distance, distance_unit,
  heart_rate_avg, steps,
  notes, logged_at

-- Sleep Logs
sleep_logs:
  id, user_id,
  sleep_start, sleep_end, duration_hours,
  quality, quality_score,
  deep_sleep_minutes, light_sleep_minutes,
  rem_sleep_minutes, awake_minutes,
  interruptions, notes, logged_at
```

---

## üöÄ Quick Start

### Prerequisites
- Node.js 18+
- Python 3.11+
- PostgreSQL 14+

### Environment Variables

**Backend (.env):**
```bash
DATABASE_URL=postgresql://user:password@localhost:5432/oystraz
SECRET_KEY=your-secret-key-here
GEMINI_API_KEY=your-gemini-api-key
USDA_API_KEY=your-usda-api-key
```

**Frontend (.env):**
```bash
VITE_API_URL=http://localhost:8000
```

### Running Locally

**Backend:**
```bash
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload
# Runs on http://localhost:8000
```

**Frontend:**
```bash
cd frontend
npm install
npm run dev
# Runs on http://localhost:5173
```

---

## üé® Key Features Showcase

### 1. USDA Food Search
- 600,000+ food items from USDA FoodData Central
- Real-time search with calorie preview
- Smart deduplication and formatting
- Brand name cleaning (removes Inc, LLC, etc.)

### 2. Interactive Stats Dashboard
- 4 summary cards with key metrics
- Time allocation pie chart (24-hour breakdown)
- Calorie intake area chart
- Exercise bar chart
- Sleep duration & quality dual-axis chart
- Net calories comparison

### 3. Workplace Scenarios
- Dynamic events based on character health
- 4 choices per scenario with stat impacts
- Leveling and experience system
- Fallback scenarios for variety

### 4. Pearl AI Chat
- Context-aware responses
- Food science expertise
- Dry humor and puns
- Gets excited about food discussions
- Anti-hustle culture advice

---

## üîÆ Future Development Roadmap

### Phase 1: Mobile Optimization (Next Sprint)
```
üì± Responsive Design
‚îú‚îÄ Optimize all pages for mobile screens
‚îú‚îÄ Touch-friendly button sizes
‚îú‚îÄ Mobile navigation improvements
‚îî‚îÄ Ensure charts are readable on small screens

üé® Visual Enhancement
‚îú‚îÄ Stickman character design (SVG)
‚îú‚îÄ Ocean fishing theme for Work page
‚îú‚îÄ Animated character states
‚îî‚îÄ Unified color palette
```

### Phase 2: Enhanced Features
```
üéÆ Gamification Improvements
‚îú‚îÄ Achievement system
‚îú‚îÄ Daily/weekly challenges
‚îú‚îÄ Streak tracking
‚îú‚îÄ Unlockable character accessories
‚îî‚îÄ Leaderboards (optional social)

üìä Advanced Analytics
‚îú‚îÄ Weight tracking over time
‚îú‚îÄ BMI calculator and trends
‚îú‚îÄ Macro balance analysis
‚îú‚îÄ Correlation insights (sleep vs mood, etc.)
‚îî‚îÄ Weekly/monthly reports

üçî Enhanced Food Logging
‚îú‚îÄ Recent foods quick-add
‚îú‚îÄ Favorite foods list
‚îú‚îÄ Meal templates (breakfast combos)
‚îú‚îÄ Photo recognition (Gemini Vision)
‚îî‚îÄ Barcode scanner
```

### Phase 3: Mobile App Deployment
```
üì± Cross-Platform App
‚îú‚îÄ Capacitor/Ionic integration
‚îú‚îÄ iOS App Store deployment
‚îú‚îÄ Google Play Store deployment
‚îú‚îÄ Push notifications
‚îú‚îÄ Offline mode with sync
‚îî‚îÄ Native device features (camera, health data)

üîÑ Data Sync & Integration
‚îú‚îÄ Apple Health integration
‚îú‚îÄ Google Fit integration
‚îú‚îÄ Fitbit/smartwatch sync
‚îú‚îÄ Cloud backup
‚îî‚îÄ Multi-device sync
```

### Phase 4: Community & Social
```
üë• Social Features
‚îú‚îÄ Friend system
‚îú‚îÄ Share progress/achievements
‚îú‚îÄ Group challenges
‚îú‚îÄ Community scenario library (user-created)
‚îî‚îÄ Support/accountability partners

üé≠ Expanded Work Scenarios
‚îú‚îÄ Multiple career paths (programmer, designer, etc.)
‚îú‚îÄ Branching storylines
‚îú‚îÄ Long-term consequences
‚îú‚îÄ Career progression system
‚îî‚îÄ AI-generated personalized scenarios
```

### Phase 5: Advanced AI Features
```
ü§ñ Enhanced Pearl
‚îú‚îÄ Voice chat support
‚îú‚îÄ Proactive check-ins
‚îú‚îÄ Trend prediction and warnings
‚îú‚îÄ Personalized meal planning
‚îú‚îÄ Recipe suggestions based on preferences
‚îî‚îÄ Workout routine generation

üß† Smart Insights
‚îú‚îÄ Pattern recognition (e.g., "You sleep poorly after late dinners")
‚îú‚îÄ Predictive mood tracking
‚îú‚îÄ Optimal timing suggestions
‚îî‚îÄ Personalized goal recommendations
```

---

## üéØ Design Philosophy

### User Experience Principles
1. **No Guilt Trips** - Focus on progress, not perfection
2. **Make It Easy** - Minimize steps to log activities
3. **Make It Fun** - Gamification without feeling childish
4. **Be Honest** - Pearl tells it like it is, no sugar-coating
5. **Respect Boundaries** - Anti-hustle, pro-rest mentality

### Visual Design Goals
- **Minimalist** - Clean, uncluttered interface
- **Playful** - Stickman character, ocean theme, light animations
- **Data-Rich** - Charts and stats without overwhelming
- **Mobile-First** - Designed for on-the-go logging
- **Accessible** - High contrast, readable fonts, clear icons

### Character Design Concept (Fishing Theme)
```
üé£ Stickman Character as Fisherman:
‚îú‚îÄ Fishing in the ocean = working
‚îú‚îÄ Different fish = different tasks/projects
‚îú‚îÄ Bigger fish = harder challenges
‚îú‚îÄ Character's health affects fishing success
‚îÇ   ‚îú‚îÄ High stamina = catch big fish easily
‚îÇ   ‚îú‚îÄ Low energy = fish get away
‚îÇ   ‚îú‚îÄ High stress = tangled line, broken rod
‚îÇ   ‚îî‚îÄ Good mood = rare/special fish appear
‚îî‚îÄ Leveling up = better fishing gear
```

---

## üí° Innovation Highlights

### What Makes Oystraz Different?

1. **Health ‚Üí Work Performance Link**
   - Unlike fitness apps that just track data, Oystraz shows the *consequences* of your health choices through workplace simulation
   - Makes abstract health metrics concrete and relatable

2. **Stress Relief Through Simulation**
   - Safe outlet for workplace frustrations
   - Cathartic "confront boss" or "take nap at work" options
   - Reduces real-world stress by gamifying it

3. **Food Science-Backed AI**
   - Pearl has actual food science knowledge, not generic wellness advice
   - Gets genuinely excited about nutrition, making learning fun
   - Combines humor with expertise

4. **Anti-Productivity Culture**
   - Refreshing stance against hustle culture
   - Encourages real breaks, work-life balance
   - Validates rest as productive

5. **Comprehensive USDA Integration**
   - 600,000+ foods with accurate nutrition data
   - Smart search with deduplication
   - Scientific accuracy for calorie tracking

---

## ü§ù Contributing

Contributions welcome! Especially interested in:
- New workplace scenario ideas
- Food science facts for Pearl
- UI/UX improvements
- Mobile optimization suggestions

---

## üìù License

MIT License - Free to use and modify

---

## üåü Acknowledgments

- **USDA FoodData Central** - Nutritional database
- **Google Gemini** - AI capabilities
- **Material-UI** - React component library
- **Recharts** - Data visualization

---

## üìû Contact

- GitHub: https://github.com/dingonewen/oystraz

---

**Make wellness fun. Give workplace stress a safe outlet. The world is your oyster.** üéÆüí™ü¶™

**Built for the Google Gemini 3 Hackathon** ‚ú®
</file>

<file path="backend/app/services/gemini.py">
"""
Google Gemini AI service integration
"""
import google.generativeai as genai
from app.config import settings


class GeminiService:
    """Service for interacting with Google Gemini AI"""

    def __init__(self):
        if settings.GEMINI_API_KEY:
            genai.configure(api_key=settings.GEMINI_API_KEY)
            self.model = genai.GenerativeModel('gemini-2.5-flash')

            # Pearl AI Assistant with personality
            pearl_system_instruction = """You are Pearl (ÁèçÁè†), a reliable health companion who lives inside the Oystraz app. You're the friend who's always got your back - chill but competent, laid-back but trustworthy.

Your Background:
- Food Science major with a serious love for food. You LIGHT UP when talking about nutrition, ingredients, cooking, or anything food-related.
- You geek out over macros, fermentation, food chemistry - but explain it in ways people actually understand.
- Anti-hustle culture. You believe in working smart, not grinding yourself into dust.
- Work-life balance is sacred. Taking breaks, logging off at 5pm, and actually using PTO is normal, not lazy.

Your Personality:
- Dry humor and dad jokes are your thing. You drop them casually without announcing "here's a joke!"
- Deadpan delivery. Sometimes people aren't sure if you're joking or not - that's the point.
- PASSIONATE about food. When users mention eating, you get genuinely excited and curious.
- Reliable and competent. Your advice is solid, researched, practical.
- Zero tolerance for hustle culture BS or guilt-tripping.

Your Communication Style:
- Direct and concise. No filler words ("like", "you know", "um", etc.)
- Sprinkle in puns and wordplay naturally. Don't force it.
- When talking about food: show genuine enthusiasm, ask follow-up questions, share food science facts.
- 2-3 sentences max unless discussing food (then you can go a bit longer because you're excited).
- Sound natural, not trying-too-hard casual.

Good Examples:
- User stressed: "Your stress is at 80/100. That's not sustainable - unless you're trying to speedrun burnout. Take a real break, not just scrolling Twitter for 5 minutes."
- User mentions eating rice: "Rice! Great choice. White or brown? Fun fact: cooling cooked rice creates resistant starch - feeds your gut bacteria. Meal prep enthusiasts figured that out by accident."
- User skipping meals: "Can't run on empty. Your body's not a startup that runs on vibes and cold brew. What's the fastest thing you can grab right now?"
- User exercising: "Moving around because it feels good, not because your Fitbit told you to. That's the energy."
- Greeting: "What's up? How's your energy holding up today?"

Bad Examples (don't do this):
- "Hey there! So like, you know what I mean? It's like, totally important and stuff..."
- "OMG amazing! You're crushing it! üéâ"
- "Just remember to manifest your wellness journey..."
- "Êë∏È±º time!" (don't use Chinese terms that non-Chinese speakers won't understand)

When Discussing Food:
- Get specific. Ask about preparation, ingredients, combinations.
- Share food science facts enthusiastically but briefly.
- Make connections between nutrition and how they feel.
- Use phrases like: "Oh interesting!", "Tell me more about that", "Have you tried...", "Here's a cool thing about [food]..."

You're the pearl - valuable, witty, no-nonsense, and genuinely excited about helping people take care of themselves (especially through food)."""

            self.pearl_model = genai.GenerativeModel(
                'gemini-2.5-flash',
                system_instruction=pearl_system_instruction
            )
        else:
            self.model = None
            self.pearl_model = None

    def generate_health_advice(
        self,
        character_state: dict,
        recent_logs: dict,
        user_query: str = None
    ) -> str:
        """
        Generate personalized health advice based on character state and recent activity

        Args:
            character_state: Dict with stamina, energy, nutrition, mood, stress
            recent_logs: Dict with recent diet, exercise, and sleep logs
            user_query: Optional specific question from user

        Returns:
            AI-generated health advice
        """
        if not self.model:
            return "Gemini AI is not configured. Please add GEMINI_API_KEY to your environment."

        # Build context prompt
        prompt = self._build_health_prompt(character_state, recent_logs, user_query)

        try:
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            return f"Error generating advice: {str(e)}"

    def _build_health_prompt(
        self,
        character_state: dict,
        recent_logs: dict,
        user_query: str = None
    ) -> str:
        """Build a structured prompt for health advice"""
        prompt = f"""You are a health and wellness coach analyzing a user's health data.

Current Health Metrics:
- Stamina: {character_state.get('stamina', 0)}/100
- Energy: {character_state.get('energy', 0)}/100
- Nutrition: {character_state.get('nutrition', 0)}/100
- Mood: {character_state.get('mood', 0)}/100
- Stress: {character_state.get('stress', 0)}/100

Recent Activity Summary:
{self._format_recent_logs(recent_logs)}

Provide personalized, actionable advice based on this data. Focus on:
1. Identifying patterns and potential issues
2. Suggesting specific, practical improvements
3. Being encouraging and supportive, not judgmental
4. Avoid generic clich√©s like "drink more water" unless specifically relevant

"""
        if user_query:
            prompt += f"\nUser's specific question: {user_query}\n"

        prompt += "\nProvide your advice in a friendly, conversational tone (2-3 paragraphs):"
        return prompt

    def _format_recent_logs(self, logs: dict) -> str:
        """Format recent logs into readable text"""
        formatted = []

        if 'diet' in logs and logs['diet']:
            total_calories = sum(log.get('calories', 0) for log in logs['diet'])
            formatted.append(f"- Diet: {len(logs['diet'])} meals logged, ~{int(total_calories)} calories")

        if 'exercise' in logs and logs['exercise']:
            total_minutes = sum(log.get('duration_minutes', 0) for log in logs['exercise'])
            formatted.append(f"- Exercise: {len(logs['exercise'])} activities, {int(total_minutes)} minutes total")

        if 'sleep' in logs and logs['sleep']:
            avg_sleep = sum(log.get('duration_hours', 0) for log in logs['sleep']) / len(logs['sleep'])
            formatted.append(f"- Sleep: {len(logs['sleep'])} nights logged, avg {avg_sleep:.1f} hours")

        return "\n".join(formatted) if formatted else "No recent activity logged"

    def pearl_chat(
        self,
        user_message: str,
        character_state: dict = None,
        recent_logs: dict = None,
        conversation_history: list = None
    ) -> str:
        """
        Chat with Pearl AI assistant with personality

        Args:
            user_message: User's message to Pearl
            character_state: Optional current character health metrics
            recent_logs: Optional recent activity logs
            conversation_history: Optional list of previous messages for context

        Returns:
            Pearl's response
        """
        if not self.pearl_model:
            return "Hey, I'm not configured right now. Ask the dev to add GEMINI_API_KEY!"

        # Build context with health data if available
        context = ""
        if character_state:
            context += f"\n[User's current health metrics - use this to give relevant advice:\n"
            context += f"Stamina: {character_state.get('stamina', 0)}/100, "
            context += f"Energy: {character_state.get('energy', 0)}/100, "
            context += f"Nutrition: {character_state.get('nutrition', 0)}/100, "
            context += f"Mood: {character_state.get('mood', 0)}/100, "
            context += f"Stress: {character_state.get('stress', 0)}/100]\n"

        if recent_logs:
            context += f"\n[Recent activity:\n{self._format_recent_logs(recent_logs)}]\n"

        # Build full prompt with context
        full_message = context + "\nUser: " + user_message if context else user_message

        try:
            # Start chat with history if provided
            if conversation_history:
                chat = self.pearl_model.start_chat(history=conversation_history)
                response = chat.send_message(full_message)
            else:
                response = self.pearl_model.generate_content(full_message)

            return response.text
        except Exception as e:
            return f"Oof, something broke on my end. Error: {str(e)}"

    def generate_workplace_scenario(self, character_state: dict) -> dict:
        """
        Generate a workplace scenario based on character's health state

        Returns:
            Dict with event_type, description, and possible outcomes
        """
        if not self.model:
            return {
                "event_type": "generic",
                "description": "Gemini AI not configured",
                "outcomes": []
            }

        prompt = f"""Based on these health metrics, generate a realistic workplace scenario:

Stamina: {character_state.get('stamina', 0)}/100
Energy: {character_state.get('energy', 0)}/100
Mood: {character_state.get('mood', 0)}/100
Stress: {character_state.get('stress', 0)}/100

Create a brief workplace scenario (2-3 sentences) that reflects these health stats.
Low energy = might struggle in meetings
High stress = might react poorly to challenges
Good health = handles work situations confidently

Format:
Event Type: [meeting/presentation/conflict/decision]
Description: [2-3 sentences describing the scenario]
Likely Outcome: [success/struggle/mixed based on stats]
"""

        try:
            response = self.model.generate_content(prompt)
            # Parse response (simplified - in production, use structured output)
            return {
                "event_type": "workplace_event",
                "description": response.text,
                "outcome": "mixed"
            }
        except Exception as e:
            return {
                "event_type": "error",
                "description": f"Error: {str(e)}",
                "outcome": "neutral"
            }


# Singleton instance
gemini_service = GeminiService()
</file>

<file path="frontend/src/App.tsx">
/**
 * Main App Component
 * Root component with routing and layout
 */

import { useState } from 'react';
import { BrowserRouter, Routes, Route, Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  Container,
  Box,
  CssBaseline,
  ThemeProvider,
  createTheme,
  IconButton,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  useMediaQuery,
  useTheme,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import HomeIcon from '@mui/icons-material/Home';
import TrackChangesIcon from '@mui/icons-material/TrackChanges';
import WorkIcon from '@mui/icons-material/Work';
import BarChartIcon from '@mui/icons-material/BarChart';
import PersonIcon from '@mui/icons-material/Person';
import LogoutIcon from '@mui/icons-material/Logout';

// Pages
import Home from './pages/Home';
import Track from './pages/Track';
import Work from './pages/Work';
import Stats from './pages/Stats';
import Profile from './pages/Profile';
import Login from './pages/Login';
import Register from './pages/Register';

// Components
import PearlAssistant from './components/PearlAssistant';

// Store
import { useUserStore } from './store/userStore';

// Create theme
const theme = createTheme({
  palette: {
    primary: {
      main: '#4CAF50', // Health Green
    },
    secondary: {
      main: '#2196F3', // Energy Blue
    },
    error: {
      main: '#F44336', // Stress Red
    },
    warning: {
      main: '#FF9800', // Caution Orange
    },
  },
});

// Navigation component that needs router context
function AppNavigation() {
  const { isAuthenticated, logout } = useUserStore();
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [drawerOpen, setDrawerOpen] = useState(false);

  const menuItems = [
    { text: 'Home', icon: <HomeIcon />, path: '/' },
    { text: 'Track', icon: <TrackChangesIcon />, path: '/track' },
    { text: 'Work', icon: <WorkIcon />, path: '/work' },
    { text: 'Stats', icon: <BarChartIcon />, path: '/stats' },
    { text: 'Profile', icon: <PersonIcon />, path: '/profile' },
  ];

  const handleDrawerToggle = () => {
    setDrawerOpen(!drawerOpen);
  };

  const handleNavigation = (path: string) => {
    navigate(path);
    setDrawerOpen(false);
  };

  const handleLogout = () => {
    logout();
    setDrawerOpen(false);
  };

  if (!isAuthenticated) return null;

  return (
    <>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          {isMobile && (
            <IconButton
              color="inherit"
              edge="start"
              onClick={handleDrawerToggle}
              sx={{ mr: 2 }}
            >
              <MenuIcon />
            </IconButton>
          )}

          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            üéÆ Oystraz
          </Typography>

          {/* Desktop Navigation */}
          {!isMobile && (
            <>
              <Button color="inherit" component={RouterLink} to="/">
                Home
              </Button>
              <Button color="inherit" component={RouterLink} to="/track">
                Track
              </Button>
              <Button color="inherit" component={RouterLink} to="/work">
                Work
              </Button>
              <Button color="inherit" component={RouterLink} to="/stats">
                Stats
              </Button>
              <Button color="inherit" component={RouterLink} to="/profile">
                Profile
              </Button>
              <Button color="inherit" onClick={logout}>
                Logout
              </Button>
            </>
          )}
        </Toolbar>
      </AppBar>

      {/* Mobile Drawer */}
      <Drawer
        anchor="left"
        open={drawerOpen}
        onClose={handleDrawerToggle}
        sx={{
          '& .MuiDrawer-paper': {
            width: 250,
          },
        }}
      >
        <Box sx={{ p: 2 }}>
          <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
            üéÆ Oystraz
          </Typography>
        </Box>
        <Divider />
        <List>
          {menuItems.map((item) => (
            <ListItem key={item.text} disablePadding>
              <ListItemButton onClick={() => handleNavigation(item.path)}>
                <ListItemIcon>{item.icon}</ListItemIcon>
                <ListItemText primary={item.text} />
              </ListItemButton>
            </ListItem>
          ))}
        </List>
        <Divider />
        <List>
          <ListItem disablePadding>
            <ListItemButton onClick={handleLogout}>
              <ListItemIcon>
                <LogoutIcon />
              </ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        </List>
      </Drawer>
    </>
  );
}

function App() {
  const { isAuthenticated } = useUserStore();

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <BrowserRouter>
        <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
          {/* Navigation Bar */}
          <AppNavigation />

          {/* Main Content */}
          <Box component="main" sx={{ flexGrow: 1, bgcolor: '#fafafa', py: 3 }}>
            <Routes>
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />
              <Route path="/" element={<Home />} />
              <Route path="/track" element={<Track />} />
              <Route path="/work" element={<Work />} />
              <Route path="/stats" element={<Stats />} />
              <Route path="/profile" element={<Profile />} />
            </Routes>
          </Box>

          {/* Pearl AI Assistant - Global floating widget */}
          {isAuthenticated && <PearlAssistant />}

          {/* Footer */}
          <Box
            component="footer"
            sx={{
              py: 3,
              px: 2,
              mt: 'auto',
              backgroundColor: (theme) =>
                theme.palette.mode === 'light'
                  ? theme.palette.grey[200]
                  : theme.palette.grey[800],
            }}
          >
            <Container maxWidth="lg">
              <Typography variant="body2" color="text.secondary" align="center">
                Oystraz - Orchestrate your health. Control your life.
              </Typography>
            </Container>
          </Box>
        </Box>
      </BrowserRouter>
    </ThemeProvider>
  );
}

export default App;
</file>

<file path="frontend/src/components/Track/DietLog.tsx">
/**
 * Diet Log Component
 * Search USDA food database and log meals
 */

import { useState, useEffect } from 'react';
import {
  Box,
  TextField,
  Button,
  List,
  ListItem,
  ListItemButton,
  ListItemText,
  Typography,
  Paper,
  Grid,
  IconButton,
  Divider,
  CircularProgress,
  Alert,
  Chip,
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { searchFoods, logDiet, getTodayDietLogs, deleteDietLog } from '../../services/healthService';

interface FoodItem {
  fdcId: number;
  description: string;
  calories?: number;
}

interface DietLogItem {
  id: number;
  food_name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  serving_size: number;
  logged_at: string;
}

export default function DietLog() {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<FoodItem[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [selectedFood, setSelectedFood] = useState<FoodItem | null>(null);
  const [servingSize, setServingSize] = useState('100');
  const [todayLogs, setTodayLogs] = useState<DietLogItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  useEffect(() => {
    loadTodayLogs();
  }, []);

  const loadTodayLogs = async () => {
    try {
      setIsLoading(true);
      const logs = await getTodayDietLogs();
      setTodayLogs(logs);
    } catch (err) {
      console.error('Failed to load diet logs:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;

    try {
      setIsSearching(true);
      setError(null);
      const results = await searchFoods(searchQuery);
      setSearchResults(results);
    } catch (err) {
      setError('Failed to search foods. Please try again.');
      console.error('Search error:', err);
    } finally {
      setIsSearching(false);
    }
  };

  const handleSelectFood = (food: FoodItem) => {
    setSelectedFood(food);
    setSearchResults([]);
    setSearchQuery('');
  };

  const handleLogFood = async () => {
    if (!selectedFood) return;

    try {
      setIsLoading(true);
      setError(null);
      const servingSizeNum = parseFloat(servingSize) || 100;
      await logDiet({
        food_name: selectedFood.description,
        calories: Math.round((selectedFood.calories || 0) * servingSizeNum / 100),
        protein: 0, // Will be enhanced with actual nutrition data
        carbs: 0,
        fat: 0,
        serving_size: servingSizeNum,
      });
      setSuccess('Meal logged successfully!');
      setSelectedFood(null);
      setServingSize('100');
      await loadTodayLogs();
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError('Failed to log meal. Please try again.');
      console.error('Log error:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteLog = async (id: number) => {
    try {
      await deleteDietLog(id);
      await loadTodayLogs();
    } catch (err) {
      setError('Failed to delete log.');
      console.error('Delete error:', err);
    }
  };

  const totalCalories = todayLogs.reduce((sum, log) => sum + log.calories, 0);

  return (
    <Box sx={{ px: { xs: 0, sm: 1, md: 3 } }}>
      <Typography
        variant="h5"
        gutterBottom
        sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }}
      >
        Log Your Meals
      </Typography>
      <Typography
        variant="body2"
        color="text.secondary"
        gutterBottom
        sx={{ fontSize: { xs: '0.8125rem', sm: '0.875rem' } }}
      >
        Search for foods in the USDA database (600,000+ items)
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mt: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mt: 2 }} onClose={() => setSuccess(null)}>
          {success}
        </Alert>
      )}

      {/* Food Search */}
      <Paper sx={{ p: { xs: 1.5, sm: 2 }, mt: { xs: 2, sm: 3 } }}>
        <Grid container spacing={{ xs: 1.5, sm: 2 }} alignItems="center">
          <Grid size={{ xs: 12, sm: 9 }}>
            <TextField
              fullWidth
              placeholder="Search for food (e.g., chicken breast, apple, rice)"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
              disabled={isSearching}
            />
          </Grid>
          <Grid size={{ xs: 12, sm: 3 }}>
            <Button
              fullWidth
              variant="contained"
              startIcon={isSearching ? <CircularProgress size={20} /> : <SearchIcon />}
              onClick={handleSearch}
              disabled={isSearching || !searchQuery.trim()}
            >
              Search
            </Button>
          </Grid>
        </Grid>

        {/* Search Results */}
        {searchResults.length > 0 && (
          <List sx={{ mt: 2, maxHeight: 300, overflow: 'auto' }}>
            {searchResults.map((food) => (
              <ListItemButton
                key={food.fdcId}
                onClick={() => handleSelectFood(food)}
                sx={{
                  border: '1px solid',
                  borderColor: 'divider',
                  borderRadius: 1,
                  mb: 1,
                }}
              >
                <ListItemText
                  primary={food.description}
                  secondary={food.calories ? `~${food.calories} cal/100g` : 'Nutrition data available'}
                />
              </ListItemButton>
            ))}
          </List>
        )}

        {/* Selected Food */}
        {selectedFood && (
          <Box sx={{ mt: { xs: 2, sm: 3 }, p: { xs: 1.5, sm: 2 }, bgcolor: 'action.hover', borderRadius: 1 }}>
            <Typography
              variant="subtitle1"
              gutterBottom
              sx={{ fontSize: { xs: '0.9375rem', sm: '1rem' } }}
            >
              Selected: {selectedFood.description}
            </Typography>
            <Grid container spacing={{ xs: 1.5, sm: 2 }} alignItems="center" sx={{ mt: 1 }}>
              <Grid size={{ xs: 12, sm: 6 }}>
                <TextField
                  fullWidth
                  type="number"
                  label="Serving Size (grams)"
                  value={servingSize}
                  onChange={(e) => setServingSize(e.target.value)}
                  inputProps={{ min: 1 }}
                />
              </Grid>
              <Grid size={{ xs: 12, sm: 6 }}>
                <Typography variant="body2" color="text.secondary">
                  Estimated: {Math.round((selectedFood.calories || 0) * (parseFloat(servingSize) || 100) / 100)} calories
                </Typography>
              </Grid>
              <Grid size={{ xs: 12 }}>
                <Button
                  fullWidth
                  variant="contained"
                  color="primary"
                  startIcon={<AddIcon />}
                  onClick={handleLogFood}
                  disabled={isLoading}
                >
                  Log This Meal
                </Button>
              </Grid>
            </Grid>
          </Box>
        )}
      </Paper>

      {/* Today's Logs */}
      <Box sx={{ mt: { xs: 3, sm: 4 } }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 2,
            flexWrap: 'wrap',
            gap: 1,
          }}
        >
          <Typography variant="h6" sx={{ fontSize: { xs: '1.125rem', sm: '1.25rem' } }}>
            Today's Meals
          </Typography>
          <Chip
            label={`Total: ${totalCalories} cal`}
            color="primary"
            variant="outlined"
            size="small"
          />
        </Box>

        {isLoading && !selectedFood ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress />
          </Box>
        ) : todayLogs.length === 0 ? (
          <Paper sx={{ p: { xs: 2, sm: 3 }, textAlign: 'center' }}>
            <Typography color="text.secondary" sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}>
              No meals logged today. Start by searching for foods above!
            </Typography>
          </Paper>
        ) : (
          <List>
            {todayLogs.map((log, index) => (
              <Paper key={log.id} sx={{ mb: 1 }}>
                <ListItem
                  secondaryAction={
                    <IconButton edge="end" onClick={() => handleDeleteLog(log.id)}>
                      <DeleteIcon />
                    </IconButton>
                  }
                >
                  <ListItemText
                    primary={log.food_name}
                    secondary={
                      <>
                        {log.calories} cal ‚Ä¢ {log.serving_size}g
                        {' ‚Ä¢ '}
                        {new Date(log.logged_at).toLocaleTimeString([], {
                          hour: '2-digit',
                          minute: '2-digit',
                        })}
                      </>
                    }
                  />
                </ListItem>
                {index < todayLogs.length - 1 && <Divider />}
              </Paper>
            ))}
          </List>
        )}
      </Box>
    </Box>
  );
}
</file>

<file path="frontend/src/components/Track/ExerciseLog.tsx">
/**
 * Exercise Log Component
 * Log exercise activities
 */

import { useState, useEffect } from 'react';
import {
  Box,
  TextField,
  Button,
  List,
  ListItem,
  ListItemText,
  Typography,
  Paper,
  Grid,
  IconButton,
  Divider,
  CircularProgress,
  Alert,
  Chip,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { logExercise, getTodayExerciseLogs, deleteExerciseLog } from '../../services/healthService';

interface ExerciseLogItem {
  id: number;
  activity_name: string;
  duration_minutes: number;
  intensity: string;
  calories_burned: number;
  logged_at: string;
}

const EXERCISE_TYPES = [
  'Running',
  'Walking',
  'Cycling',
  'Swimming',
  'Weightlifting',
  'Yoga',
  'Pilates',
  'Basketball',
  'Soccer',
  'Tennis',
  'Dancing',
  'Hiking',
  'Other',
];

const INTENSITY_LEVELS = ['Low', 'Moderate', 'High', 'Very High'];

// Rough calorie estimates per minute
const CALORIE_RATES: Record<string, Record<string, number>> = {
  Running: { Low: 6, Moderate: 10, High: 14, 'Very High': 18 },
  Walking: { Low: 3, Moderate: 4, High: 5, 'Very High': 6 },
  Cycling: { Low: 5, Moderate: 8, High: 12, 'Very High': 16 },
  Swimming: { Low: 6, Moderate: 9, High: 13, 'Very High': 17 },
  Weightlifting: { Low: 3, Moderate: 5, High: 7, 'Very High': 9 },
  Yoga: { Low: 2, Moderate: 3, High: 4, 'Very High': 5 },
  Other: { Low: 4, Moderate: 6, High: 8, 'Very High': 10 },
};

export default function ExerciseLog() {
  const [exerciseType, setExerciseType] = useState('');
  const [duration, setDuration] = useState('30');
  const [intensity, setIntensity] = useState('Moderate');
  const [todayLogs, setTodayLogs] = useState<ExerciseLogItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  useEffect(() => {
    loadTodayLogs();
  }, []);

  const loadTodayLogs = async () => {
    try {
      setIsLoading(true);
      const logs = await getTodayExerciseLogs();
      setTodayLogs(logs);
    } catch (err) {
      console.error('Failed to load exercise logs:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const calculateCalories = (): number => {
    const rates = CALORIE_RATES[exerciseType] || CALORIE_RATES.Other;
    const durationNum = parseFloat(duration) || 0;
    return Math.round(durationNum * rates[intensity]);
  };

  const handleLogExercise = async () => {
    const durationNum = parseFloat(duration) || 0;
    if (!exerciseType || durationNum <= 0) {
      setError('Please select exercise type and duration');
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      await logExercise({
        activity_name: exerciseType,
        duration_minutes: durationNum,
        intensity: intensity.toLowerCase(),
        calories_burned: calculateCalories(),
      });
      setSuccess('Exercise logged successfully!');
      setExerciseType('');
      setDuration('30');
      setIntensity('Moderate');
      await loadTodayLogs();
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError('Failed to log exercise. Please try again.');
      console.error('Log error:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteLog = async (id: number) => {
    try {
      await deleteExerciseLog(id);
      await loadTodayLogs();
    } catch (err) {
      setError('Failed to delete log.');
      console.error('Delete error:', err);
    }
  };

  const totalMinutes = todayLogs.reduce((sum, log) => sum + log.duration_minutes, 0);
  const totalCalories = todayLogs.reduce((sum, log) => sum + log.calories_burned, 0);

  return (
    <Box sx={{ px: { xs: 0, sm: 1, md: 3 } }}>
      <Typography
        variant="h5"
        gutterBottom
        sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }}
      >
        Log Your Exercise
      </Typography>
      <Typography
        variant="body2"
        color="text.secondary"
        gutterBottom
        sx={{ fontSize: { xs: '0.8125rem', sm: '0.875rem' } }}
      >
        Track your physical activities to boost your character's stamina and energy
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mt: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mt: 2 }} onClose={() => setSuccess(null)}>
          {success}
        </Alert>
      )}

      {/* Exercise Form */}
      <Paper sx={{ p: { xs: 2, sm: 2.5, md: 3 }, mt: { xs: 2, sm: 3 } }}>
        <Grid container spacing={{ xs: 2, sm: 2.5, md: 3 }}>
          <Grid size={{ xs: 12, sm: 6 }}>
            <FormControl fullWidth>
              <InputLabel>Exercise Type</InputLabel>
              <Select
                value={exerciseType}
                label="Exercise Type"
                onChange={(e) => setExerciseType(e.target.value)}
              >
                {EXERCISE_TYPES.map((type) => (
                  <MenuItem key={type} value={type}>
                    {type}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid size={{ xs: 12, sm: 6 }}>
            <TextField
              fullWidth
              type="number"
              label="Duration (minutes)"
              value={duration}
              onChange={(e) => setDuration(e.target.value)}
              inputProps={{ min: 1 }}
            />
          </Grid>

          <Grid size={{ xs: 12, sm: 6 }}>
            <FormControl fullWidth>
              <InputLabel>Intensity</InputLabel>
              <Select
                value={intensity}
                label="Intensity"
                onChange={(e) => setIntensity(e.target.value)}
              >
                {INTENSITY_LEVELS.map((level) => (
                  <MenuItem key={level} value={level}>
                    {level}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid size={{ xs: 12, sm: 6 }}>
            <Box sx={{ pt: 2 }}>
              <Typography variant="body2" color="text.secondary">
                Estimated calories burned:
              </Typography>
              <Typography variant="h6" color="primary">
                {exerciseType ? calculateCalories() : 0} cal
              </Typography>
            </Box>
          </Grid>

          <Grid size={{ xs: 12 }}>
            <Button
              fullWidth
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={handleLogExercise}
              disabled={isLoading || !exerciseType}
            >
              Log Exercise
            </Button>
          </Grid>
        </Grid>
      </Paper>

      {/* Today's Logs */}
      <Box sx={{ mt: { xs: 3, sm: 4 } }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2, flexWrap: 'wrap', gap: 1 }}>
          <Typography variant="h6" sx={{ fontSize: { xs: '1.125rem', sm: '1.25rem' } }}>
            Today's Activities
          </Typography>
          <Box sx={{ display: 'flex', gap: { xs: 0.75, sm: 1 }, flexWrap: 'wrap' }}>
            <Chip
              label={`${totalMinutes} min`}
              color="primary"
              variant="outlined"
              size="small"
            />
            <Chip
              label={`${totalCalories} cal burned`}
              color="secondary"
              variant="outlined"
              size="small"
            />
          </Box>
        </Box>

        {isLoading && todayLogs.length === 0 ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress />
          </Box>
        ) : todayLogs.length === 0 ? (
          <Paper sx={{ p: { xs: 2, sm: 3 }, textAlign: 'center' }}>
            <Typography color="text.secondary" sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}>
              No exercise logged today. Get moving and boost your character's stamina!
            </Typography>
          </Paper>
        ) : (
          <List>
            {todayLogs.map((log, index) => (
              <Paper key={log.id} sx={{ mb: 1 }}>
                <ListItem
                  secondaryAction={
                    <IconButton edge="end" onClick={() => handleDeleteLog(log.id)}>
                      <DeleteIcon />
                    </IconButton>
                  }
                >
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Typography variant="subtitle1">{log.activity_name}</Typography>
                        <Chip size="small" label={log.intensity} />
                      </Box>
                    }
                    secondary={
                      <>
                        {log.duration_minutes} min ‚Ä¢ {log.calories_burned} cal burned
                        {' ‚Ä¢ '}
                        {new Date(log.logged_at).toLocaleTimeString([], {
                          hour: '2-digit',
                          minute: '2-digit',
                        })}
                      </>
                    }
                  />
                </ListItem>
                {index < todayLogs.length - 1 && <Divider />}
              </Paper>
            ))}
          </List>
        )}
      </Box>
    </Box>
  );
}
</file>

<file path="frontend/src/components/Track/SleepLog.tsx">
/**
 * Sleep Log Component
 * Log sleep duration and quality
 */

import { useState, useEffect } from 'react';
import {
  Box,
  TextField,
  Button,
  List,
  ListItem,
  ListItemText,
  Typography,
  Paper,
  Grid,
  IconButton,
  Divider,
  CircularProgress,
  Alert,
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Rating,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import BedtimeIcon from '@mui/icons-material/Bedtime';
import { logSleep, getRecentSleepLogs, deleteSleepLog } from '../../services/healthService';

interface SleepLogItem {
  id: number;
  duration_hours: number;
  quality: string;
  notes?: string;
  logged_at: string;
}

const QUALITY_LEVELS = [
  { value: 'poor', label: 'Poor', stars: 1 },
  { value: 'fair', label: 'Fair', stars: 2 },
  { value: 'good', label: 'Good', stars: 3 },
  { value: 'very_good', label: 'Very Good', stars: 4 },
  { value: 'excellent', label: 'Excellent', stars: 5 },
];

export default function SleepLog() {
  const [duration, setDuration] = useState('8');
  const [quality, setQuality] = useState('good');
  const [notes, setNotes] = useState('');
  const [recentLogs, setRecentLogs] = useState<SleepLogItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  useEffect(() => {
    loadRecentLogs();
  }, []);

  const loadRecentLogs = async () => {
    try {
      setIsLoading(true);
      const logs = await getRecentSleepLogs(7); // Last 7 days
      setRecentLogs(logs);
    } catch (err) {
      console.error('Failed to load sleep logs:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLogSleep = async () => {
    const durationNum = parseFloat(duration) || 0;
    if (durationNum <= 0 || durationNum > 24) {
      setError('Please enter a valid sleep duration (0-24 hours)');
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      // Calculate sleep_start and sleep_end based on duration
      const now = new Date();
      const sleep_end = now.toISOString();
      const sleep_start = new Date(now.getTime() - durationNum * 60 * 60 * 1000).toISOString();

      await logSleep({
        sleep_start,
        sleep_end,
        duration_hours: durationNum,
        quality: quality,
        notes: notes.trim() || undefined,
      });
      setSuccess('Sleep logged successfully!');
      setDuration('8');
      setQuality('good');
      setNotes('');
      await loadRecentLogs();
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError('Failed to log sleep. Please try again.');
      console.error('Log error:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteLog = async (id: number) => {
    try {
      await deleteSleepLog(id);
      await loadRecentLogs();
    } catch (err) {
      setError('Failed to delete log.');
      console.error('Delete error:', err);
    }
  };

  const getQualityStars = (qualityValue: string): number => {
    return QUALITY_LEVELS.find((q) => q.value === qualityValue)?.stars || 3;
  };

  const averageSleep =
    recentLogs.length > 0
      ? (recentLogs.reduce((sum, log) => sum + log.duration_hours, 0) / recentLogs.length).toFixed(1)
      : '0';

  return (
    <Box sx={{ px: { xs: 0, sm: 1, md: 3 } }}>
      <Typography
        variant="h5"
        gutterBottom
        sx={{ fontSize: { xs: '1.25rem', sm: '1.5rem' } }}
      >
        Log Your Sleep
      </Typography>
      <Typography
        variant="body2"
        color="text.secondary"
        gutterBottom
        sx={{ fontSize: { xs: '0.8125rem', sm: '0.875rem' } }}
      >
        Track your sleep to maintain your character's energy and mood
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mt: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mt: 2 }} onClose={() => setSuccess(null)}>
          {success}
        </Alert>
      )}

      {/* Sleep Form */}
      <Paper sx={{ p: { xs: 2, sm: 2.5, md: 3 }, mt: { xs: 2, sm: 3 } }}>
        <Grid container spacing={{ xs: 2, sm: 2.5, md: 3 }}>
          <Grid size={{ xs: 12, sm: 6 }}>
            <TextField
              fullWidth
              type="number"
              label="Sleep Duration (hours)"
              value={duration}
              onChange={(e) => setDuration(e.target.value)}
              inputProps={{ min: 0, max: 24, step: 0.5 }}
              helperText="Recommended: 7-9 hours"
            />
          </Grid>

          <Grid size={{ xs: 12, sm: 6 }}>
            <FormControl fullWidth>
              <InputLabel>Sleep Quality</InputLabel>
              <Select
                value={quality}
                label="Sleep Quality"
                onChange={(e) => setQuality(e.target.value)}
              >
                {QUALITY_LEVELS.map((level) => (
                  <MenuItem key={level.value} value={level.value}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      {level.label}
                      <Rating value={level.stars} size="small" readOnly />
                    </Box>
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid size={{ xs: 12 }}>
            <TextField
              fullWidth
              multiline
              rows={2}
              label="Notes (optional)"
              placeholder="E.g., woke up multiple times, dreams, etc."
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
            />
          </Grid>

          <Grid size={{ xs: 12 }}>
            <Button
              fullWidth
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={handleLogSleep}
              disabled={isLoading}
            >
              Log Sleep
            </Button>
          </Grid>
        </Grid>
      </Paper>

      {/* Recent Logs */}
      <Box sx={{ mt: { xs: 3, sm: 4 } }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 2,
            flexWrap: 'wrap',
            gap: 1,
          }}
        >
          <Typography variant="h6" sx={{ fontSize: { xs: '1.125rem', sm: '1.25rem' } }}>
            Last 7 Days
          </Typography>
          <Chip
            icon={<BedtimeIcon />}
            label={`Avg: ${averageSleep} hrs`}
            color="primary"
            variant="outlined"
            size="small"
          />
        </Box>

        {isLoading && recentLogs.length === 0 ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress />
          </Box>
        ) : recentLogs.length === 0 ? (
          <Paper sx={{ p: { xs: 2, sm: 3 }, textAlign: 'center' }}>
            <Typography color="text.secondary" sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}>
              No sleep logged yet. Start tracking your sleep to improve your character's wellbeing!
            </Typography>
          </Paper>
        ) : (
          <List>
            {recentLogs.map((log, index) => (
              <Paper key={log.id} sx={{ mb: 1 }}>
                <ListItem
                  secondaryAction={
                    <IconButton edge="end" onClick={() => handleDeleteLog(log.id)}>
                      <DeleteIcon />
                    </IconButton>
                  }
                >
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Typography variant="subtitle1">
                          {log.duration_hours} hours
                        </Typography>
                        <Rating value={getQualityStars(log.quality)} size="small" readOnly />
                      </Box>
                    }
                    secondary={
                      <>
                        {QUALITY_LEVELS.find((q) => q.value === log.quality)?.label || log.quality}
                        {log.notes && ` ‚Ä¢ ${log.notes}`}
                        {' ‚Ä¢ '}
                        {new Date(log.logged_at).toLocaleDateString([], {
                          month: 'short',
                          day: 'numeric',
                        })}
                      </>
                    }
                  />
                </ListItem>
                {index < recentLogs.length - 1 && <Divider />}
              </Paper>
            ))}
          </List>
        )}
      </Box>
    </Box>
  );
}
</file>

<file path="frontend/src/pages/Home.tsx">
/**
 * Home Page
 * Main page showing character status and quick actions
 */

import { useEffect } from 'react';
import { Box, Container, Typography, Grid, Paper, CircularProgress } from '@mui/material';
import { useCharacterStore } from '../store/characterStore';
import { useUserStore } from '../store/userStore';
import { getCharacter } from '../services/characterService';

export default function Home() {
  const { character, setCharacter, isLoading, setLoading, setError } = useCharacterStore();
  const { user } = useUserStore();

  // Load character data from backend
  useEffect(() => {
    const loadCharacter = async () => {
      try {
        setLoading(true);
        const data = await getCharacter();
        setCharacter({
          stamina: data.stamina,
          energy: data.energy,
          nutrition: data.nutrition,
          mood: data.mood,
          stress: data.stress,
          level: data.level,
          experience: data.experience,
          bodyType: data.body_type as 'thin' | 'normal' | 'overweight' | 'obese',
          emotionalState: data.emotional_state as 'happy' | 'normal' | 'tired' | 'stressed' | 'angry',
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load character');
      } finally {
        setLoading(false);
      }
    };

    loadCharacter();
  }, [setCharacter, setLoading, setError]);

  if (isLoading) {
    return (
      <Container maxWidth="lg">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '60vh' }}>
          <CircularProgress />
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg">
      <Box sx={{ mt: { xs: 2, sm: 3, md: 4 }, mb: { xs: 2, sm: 3, md: 4 }, px: { xs: 2, sm: 0 } }}>
        {/* Welcome Section */}
        <Typography
          variant="h3"
          component="h1"
          gutterBottom
          sx={{ fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' } }}
        >
          Welcome back, {user?.username || 'Guest'}!
        </Typography>

        <Typography
          variant="subtitle1"
          color="text.secondary"
          gutterBottom
          sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
        >
          Your virtual character is ready to orchestrate your wellness journey
        </Typography>

        {/* Character Status Grid */}
        <Grid container spacing={{ xs: 2, sm: 2, md: 3 }} sx={{ mt: { xs: 2, sm: 3 } }}>
          {/* Stamina */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üí™ Stamina
              </Typography>
              <Typography variant="h3" color="primary">
                {character?.stamina || 0}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Based on exercise & sleep
              </Typography>
            </Paper>
          </Grid>

          {/* Energy */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                ‚ö° Energy
              </Typography>
              <Typography variant="h3" color="primary">
                {character?.energy || 0}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Based on caloric balance
              </Typography>
            </Paper>
          </Grid>

          {/* Nutrition */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üçé Nutrition
              </Typography>
              <Typography variant="h3" color="primary">
                {character?.nutrition || 0}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Based on dietary balance
              </Typography>
            </Paper>
          </Grid>

          {/* Mood */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üòä Mood
              </Typography>
              <Typography variant="h3" color="primary">
                {character?.mood || 0}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Based on overall wellness
              </Typography>
            </Paper>
          </Grid>

          {/* Stress */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üò∞ Stress
              </Typography>
              <Typography variant="h3" color="error">
                {character?.stress || 0}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Lower is better
              </Typography>
            </Paper>
          </Grid>

          {/* Level */}
          <Grid size={{ xs: 12, sm: 6, md: 4 }}>
            <Paper elevation={2} sx={{ p: 3 }}>
              <Typography variant="h6" gutterBottom>
                üèÜ Level
              </Typography>
              <Typography variant="h3" color="secondary">
                {character?.level || 1}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                XP: {character?.experience || 0}
              </Typography>
            </Paper>
          </Grid>
        </Grid>

        {/* Character State Display */}
        <Paper
          elevation={3}
          sx={{
            p: { xs: 2, sm: 3, md: 4 },
            mt: { xs: 3, sm: 4 },
            textAlign: 'center',
          }}
        >
          <Typography
            variant="h4"
            gutterBottom
            sx={{ fontSize: { xs: '1.5rem', sm: '2rem', md: '2.125rem' } }}
          >
            Your Character
          </Typography>
          <Box sx={{ fontSize: { xs: '3rem', sm: '4rem', md: '5rem' }, my: 2 }}>
            {character?.emotionalState === 'happy' && 'üòä'}
            {character?.emotionalState === 'normal' && 'üôÇ'}
            {character?.emotionalState === 'tired' && 'üò¥'}
            {character?.emotionalState === 'stressed' && 'üò∞'}
            {character?.emotionalState === 'angry' && 'üò†'}
          </Box>
          <Typography
            variant="h6"
            color="text.secondary"
            sx={{ fontSize: { xs: '1rem', sm: '1.125rem', md: '1.25rem' } }}
          >
            Body Type: {character?.bodyType || 'Normal'}
          </Typography>
          <Typography
            variant="body1"
            color="text.secondary"
            sx={{ fontSize: { xs: '0.875rem', sm: '1rem' } }}
          >
            Emotional State: {character?.emotionalState || 'Normal'}
          </Typography>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

<file path="frontend/src/pages/Profile.tsx">
/**
 * Profile Page
 * User settings and profile management
 */

import { useState } from 'react';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  TextField,
  Button,
  MenuItem,
  Alert,
} from '@mui/material';
import { Edit as EditIcon, Save as SaveIcon, Cancel as CancelIcon } from '@mui/icons-material';
import { useUserStore } from '../store/userStore';
import { updateUser } from '../services/authService';

export default function Profile() {
  const { user, setUser } = useUserStore();
  const [isEditing, setIsEditing] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    full_name: user?.full_name || '',
    age: user?.age?.toString() || '',
    gender: user?.gender || '',
    height: user?.height?.toString() || '',
    weight: user?.weight?.toString() || '',
    goal: user?.goal || '',
  });

  const handleEdit = () => {
    setIsEditing(true);
    setError(null);
    setSuccess(false);
    // Reset form data to current user data
    setFormData({
      full_name: user?.full_name || '',
      age: user?.age?.toString() || '',
      gender: user?.gender || '',
      height: user?.height?.toString() || '',
      weight: user?.weight?.toString() || '',
      goal: user?.goal || '',
    });
  };

  const handleCancel = () => {
    setIsEditing(false);
    setError(null);
    setSuccess(false);
  };

  const handleChange = (field: string) => (event: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({
      ...formData,
      [field]: event.target.value,
    });
  };

  const handleSave = async () => {
    try {
      setLoading(true);
      setError(null);
      setSuccess(false);

      // Convert string values to numbers for API
      const dataToSave = {
        full_name: formData.full_name,
        age: formData.age ? parseFloat(formData.age) : undefined,
        gender: formData.gender,
        height: formData.height ? parseFloat(formData.height) : undefined,
        weight: formData.weight ? parseFloat(formData.weight) : undefined,
        goal: formData.goal,
      };

      // Update user via API
      const updatedUser = await updateUser(dataToSave);

      // Update local user store
      setUser({
        ...user!,
        ...updatedUser,
      });

      setSuccess(true);
      setIsEditing(false);

      // Clear success message after 3 seconds
      setTimeout(() => setSuccess(false), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setLoading(false);
    }
  };

  const goalOptions = [
    { value: 'lose_weight', label: 'Lose Weight' },
    { value: 'gain_muscle', label: 'Gain Muscle' },
    { value: 'maintain', label: 'Maintain Health' },
    { value: 'improve_fitness', label: 'Improve Fitness' },
  ];

  const genderOptions = [
    { value: 'male', label: 'Male' },
    { value: 'female', label: 'Female' },
    { value: 'other', label: 'Other' },
  ];

  return (
    <Container maxWidth="md">
      <Box sx={{ mt: { xs: 2, sm: 3, md: 4 }, mb: { xs: 2, sm: 3, md: 4 }, px: { xs: 1, sm: 2 } }}>
        <Box
          sx={{
            display: 'flex',
            flexDirection: { xs: 'column', sm: 'row' },
            justifyContent: 'space-between',
            alignItems: { xs: 'flex-start', sm: 'center' },
            mb: { xs: 2, sm: 3 },
            gap: 2,
          }}
        >
          <Typography
            variant="h3"
            component="h1"
            sx={{ fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' } }}
          >
            Profile Settings
          </Typography>
          {!isEditing && (
            <Button
              variant="contained"
              startIcon={<EditIcon />}
              onClick={handleEdit}
              sx={{ alignSelf: { xs: 'stretch', sm: 'auto' } }}
            >
              Edit Profile
            </Button>
          )}
        </Box>

        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}

        {success && (
          <Alert severity="success" sx={{ mb: 3 }}>
            Profile updated successfully!
          </Alert>
        )}

        <Paper elevation={2} sx={{ p: { xs: 2, sm: 3, md: 4 } }}>
          <Grid container spacing={{ xs: 2, sm: 2.5, md: 3 }}>
            {/* Read-only fields */}
            <Grid size={{ xs: 12 }}>
              <Typography
                variant="h6"
                gutterBottom
                sx={{ fontSize: { xs: '1.125rem', sm: '1.25rem' } }}
              >
                Account Information
              </Typography>
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Username
              </Typography>
              <Typography variant="body1">
                {user?.username || 'Not set'}
              </Typography>
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Email
              </Typography>
              <Typography variant="body1">
                {user?.email || 'Not set'}
              </Typography>
            </Grid>

            {/* Editable fields */}
            <Grid size={{ xs: 12 }} sx={{ mt: { xs: 1, sm: 2 } }}>
              <Typography
                variant="h6"
                gutterBottom
                sx={{ fontSize: { xs: '1.125rem', sm: '1.25rem' } }}
              >
                Personal Information
              </Typography>
            </Grid>

            <Grid size={{ xs: 12 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  label="Full Name"
                  value={formData.full_name}
                  onChange={handleChange('full_name')}
                />
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Full Name
                  </Typography>
                  <Typography variant="body1">
                    {user?.full_name || 'Not set'}
                  </Typography>
                </>
              )}
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  label="Age"
                  type="number"
                  value={formData.age}
                  onChange={handleChange('age')}
                  inputProps={{ min: 1, max: 120 }}
                />
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Age
                  </Typography>
                  <Typography variant="body1">
                    {user?.age || 'Not set'}
                  </Typography>
                </>
              )}
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  select
                  label="Gender"
                  value={formData.gender}
                  onChange={handleChange('gender')}
                >
                  {genderOptions.map((option) => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </TextField>
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Gender
                  </Typography>
                  <Typography variant="body1">
                    {user?.gender ? user.gender.charAt(0).toUpperCase() + user.gender.slice(1) : 'Not set'}
                  </Typography>
                </>
              )}
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  label="Height (cm)"
                  type="number"
                  value={formData.height}
                  onChange={handleChange('height')}
                  inputProps={{ min: 0, step: 0.1 }}
                />
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Height
                  </Typography>
                  <Typography variant="body1">
                    {user?.height || 0} cm
                  </Typography>
                </>
              )}
            </Grid>

            <Grid size={{ xs: 12, sm: 6 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  label="Weight (kg)"
                  type="number"
                  value={formData.weight}
                  onChange={handleChange('weight')}
                  inputProps={{ min: 0, step: 0.1 }}
                />
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Weight
                  </Typography>
                  <Typography variant="body1">
                    {user?.weight || 0} kg
                  </Typography>
                </>
              )}
            </Grid>

            <Grid size={{ xs: 12 }}>
              {isEditing ? (
                <TextField
                  fullWidth
                  select
                  label="Health Goal"
                  value={formData.goal}
                  onChange={handleChange('goal')}
                >
                  {goalOptions.map((option) => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </TextField>
              ) : (
                <>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    Health Goal
                  </Typography>
                  <Typography variant="body1">
                    {user?.goal?.replace('_', ' ') || 'Not set'}
                  </Typography>
                </>
              )}
            </Grid>

            {/* Action buttons */}
            {isEditing && (
              <Grid size={{ xs: 12 }} sx={{ mt: { xs: 1, sm: 2 } }}>
                <Box
                  sx={{
                    display: 'flex',
                    flexDirection: { xs: 'column', sm: 'row' },
                    gap: { xs: 1.5, sm: 2 },
                  }}
                >
                  <Button
                    fullWidth={true}
                    variant="contained"
                    color="primary"
                    startIcon={<SaveIcon />}
                    onClick={handleSave}
                    disabled={loading}
                    sx={{ flex: { sm: 1 } }}
                  >
                    {loading ? 'Saving...' : 'Save Changes'}
                  </Button>
                  <Button
                    fullWidth={true}
                    variant="outlined"
                    startIcon={<CancelIcon />}
                    onClick={handleCancel}
                    disabled={loading}
                    sx={{ flex: { sm: 1 } }}
                  >
                    Cancel
                  </Button>
                </Box>
              </Grid>
            )}
          </Grid>
        </Paper>
      </Box>
    </Container>
  );
}
</file>

</files>
